<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>三两带走</title>
	<atom:link href="http://rentb.vicp.net/feed" rel="self" type="application/rss+xml" />
	<link>http://huster.top/</link>
	<description>(任天兵)龙安的博客</description>
	<lastBuildDate>Thu, 17 Oct 2019 08:49:32 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.10</generator>

<image>
	<url>https://huster.top/wp-content/uploads/2018/09/cropped-fish_112.18181818182px_1208536_easyicon.net_-32x32.png</url>
	<title>三两带走</title>
	<link>http://huster.top/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>flink通过jdbc读取postgresql数据库里的数据</title>
		<link>https://huster.top/htmls/706.html</link>
		<comments>https://huster.top/htmls/706.html#respond</comments>
		<pubDate>Thu, 17 Oct 2019 08:49:32 +0000</pubDate>
		<dc:creator><![CDATA[龙安_任天兵]]></dc:creator>
				<category><![CDATA[flink]]></category>

		<guid isPermaLink="false">https://huster.top/?p=706</guid>
		<description><![CDATA[问题1： 从postgresql里使用flink-jdbc读取数据的问题, 数据类型不匹配，不支持jsonb等 &#8230; <a href="https://huster.top/htmls/706.html" class="more-link">继续阅读<span class="screen-reader-text">“flink通过jdbc读取postgresql数据库里的数据”</span></a>]]></description>
				<content:encoded><![CDATA[<div></div>
<div></div>
<div></div>
<div>问题1： 从postgresql里使用flink-jdbc读取数据的问题, 数据类型不匹配，不支持jsonb等其他类型.</div>
<div></div>
<div></div>
<p><span id="more-706"></span></p>
<div></div>
<div>        使用create table 语句来读取，由于postgresql里设置的是jsonb的类型, 他又不让你输入sql语句(语句里需要写CAST函数),所以就抛错了</div>
<div>Caused by: java.lang.ClassCastException: org.postgresql.util.PGobject cannot be cast to java.lang.String</div>
<div>Caused by: java.lang.ClassCastException: org.postgresql.util.PGobject cannot be cast to java.lang.String</div>
<div>    at <a href="http://org.apache.flink.api.common.typeutils.base.stringserializer.copy(stringserializer.java:33/">org.apache.flink.api.common.typeutils.base.StringSerializer.copy(StringSerializer.java:33</a>)</div>
<div>    at org.apache.flink.api.java.typeutils.runtime.RowSerializer.copy(RowSerializer.java:93)</div>
<div>    at org.apache.flink.api.java.typeutils.runtime.RowSerializer.copy(RowSerializer.java:44)</div>
<div>    at org.apache.flink.streaming.runtime.tasks.OperatorChain$CopyingChainingOutput.pushToOperator(OperatorChain.java:635)</div>
<div>    &#8230; 9 more</div>
<div></div>
<div></div>
<div>问题2: partition必须是数字类型的字段</div>
<div></div>
<div></div>
<div> 另外，因为connector.read.partition.column他使用的是between语句，所以只能是数字，时间戳等，否则也会报错</div>
<div>. partition.column must be a numeric,</div>
<div> &#8212; date, or timestamp column from the table in question.</div>
<div></div>
<div></div>
<div></div>
<div></div>
<div></div>
<div></div>
<div>Exception in thread &#8220;main&#8221; org.apache.flink.runtime.client.JobExecutionException: Job execution failed.</div>
<div>    at org.apache.flink.runtime.jobmaster.JobResult.toJobExecutionResult(JobResult.java:146)</div>
<div>    at org.apache.flink.runtime.minicluster.MiniCluster.executeJobBlocking(MiniCluster.java:627)</div>
<div>    at org.apache.flink.streaming.api.environment.LocalStreamEnvironment.execute(LocalStreamEnvironment.java:117)</div>
<div>    at org.apache.flink.streaming.api.environment.StreamExecutionEnvironment.execute(StreamExecutionEnvironment.java:1507)</div>
<div>    at com.hellobike.search.flink.task.FullIndexBuilderTask.main(FullIndexBuilderTask.java:92)</div>
<div>Caused by: java.lang.Exception: java.lang.IllegalArgumentException: open() failed.ERROR: operator does not exist: character varying &gt;= bigint</div>
<div>  建议：No operator matches the given name and argument type(s). You might need to add explicit type casts.</div>
<div>  位置：514</div>
<div>    at org.apache.flink.streaming.runtime.tasks.SourceStreamTask$LegacySourceFunctionThread.checkThrowSourceExecutionException(SourceStreamTask.java:212)</div>
<div>    at org.apache.flink.streaming.runtime.tasks.SourceStreamTask.performDefaultAction(SourceStreamTask.java:132)</div>
<div>    at org.apache.flink.streaming.runtime.tasks.StreamTask.run(StreamTask.java:298)</div>
<div>    at org.apache.flink.streaming.runtime.tasks.StreamTask.invoke(StreamTask.java:403)</div>
<div>    at org.apache.flink.runtime.taskmanager.Task.doRun(Task.java:705)</div>
<div>    at org.apache.flink.runtime.taskmanager.Task.run(Task.java:530)</div>
<div>    at java.lang.Thread.run(Thread.java:748)</div>
<div>Caused by: java.lang.IllegalArgumentException: open() failed.ERROR: operator does not exist: character varying &gt;= bigint</div>
<div>  建议：No operator matches the given name and argument type(s). You might need to add explicit type casts.</div>
<div>  位置：514</div>
<div>    at org.apache.flink.api.java.io.jdbc.JDBCInputFormat.open(JDBCInputFormat.java:250)</div>
<div>    at org.apache.flink.streaming.api.functions.source.InputFormatSourceFunction.run(InputFormatSourceFunction.java:85)</div>
<div>    at org.apache.flink.streaming.api.operators.StreamSource.run(StreamSource.java:100)</div>
<div>    at org.apache.flink.streaming.api.operators.StreamSource.run(StreamSource.java:63)</div>
<div>    at org.apache.flink.streaming.runtime.tasks.SourceStreamTask$LegacySourceFunctionThread.run(SourceStreamTask.java:202)</div>
<div>Caused by: org.postgresql.util.PSQLException: ERROR: operator does not exist: character varying &gt;= bigint</div>
<div>  建议：No operator matches the given name and argument type(s). You might need to add explicit type casts.</div>
<div>  位置：514</div>
<div>    at org.postgresql.core.v3.QueryExecutorImpl.receiveErrorResponse(QueryExecutorImpl.java:2103)</div>
<div>    at org.postgresql.core.v3.QueryExecutorImpl.processResults(QueryExecutorImpl.java:1836)</div>
<div>    at org.postgresql.core.v3.QueryExecutorImpl.execute(QueryExecutorImpl.java:257)</div>
<div>    at org.postgresql.jdbc2.AbstractJdbc2Statement.execute(AbstractJdbc2Statement.java:512)</div>
<div>    at org.postgresql.jdbc2.AbstractJdbc2Statement.executeWithFlags(AbstractJdbc2Statement.java:388)</div>
<div>    at org.postgresql.jdbc2.AbstractJdbc2Statement.executeQuery(AbstractJdbc2Statement.java:273)</div>
<div>    at org.apache.flink.api.java.io.jdbc.JDBCInputFormat.open(JDBCInputFormat.java:247)</div>
<div>    &#8230; 4 more</div>
<div>
<div></div>
</div>
]]></content:encoded>
			<wfw:commentRss>https://huster.top/htmls/706.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>flink相关 &#8211; 通过Table API写入ElasticSearch的部分源码分析</title>
		<link>https://huster.top/htmls/704.html</link>
		<comments>https://huster.top/htmls/704.html#respond</comments>
		<pubDate>Thu, 17 Oct 2019 08:49:06 +0000</pubDate>
		<dc:creator><![CDATA[龙安_任天兵]]></dc:creator>
				<category><![CDATA[flink]]></category>

		<guid isPermaLink="false">https://huster.top/?p=704</guid>
		<description><![CDATA[New ElasticSearch()…xxx&#8230;registerTableSink(); Elas &#8230; <a href="https://huster.top/htmls/704.html" class="more-link">继续阅读<span class="screen-reader-text">“flink相关 &#8211; 通过Table API写入ElasticSearch的部分源码分析”</span></a>]]></description>
				<content:encoded><![CDATA[<div>New ElasticSearch()…xxx&#8230;registerTableSink();</div>
<div></div>
<div>ElasticSearch是一个ConnectorDescriptor: 最关键的就是一个toConnectorProperties就是一个配置的map,传给factory使用，他其实是一个配置收集器.</div>
<div></div>
<div></div>
<p><span id="more-704"></span></p>
<div></div>
<div>TableFactoryUtils :  生成一个TableFactory的工具类，</div>
<div>findAndCreateTableSink( ) 通过一个描述来生成一个工厂类.//描述里有必要的配置.</div>
<div></div>
<div>先找到合适的工厂类，然后创建一个TableSink.</div>
<div></div>
<div>第一步，A先找到合适的工厂类，通过properties里的配置来寻找,</div>
<div>TableFactoryService.find(TableSinkFactory.class, properties)</div>
<div>findSingleInternal()里的两个代码是关键代码</div>
<div></div>
<div>A.1 : List&lt;TableFactory&gt; tableFactories = discoverFactories(classLoader);    通过classLoader(可以传入, 否则使用默认)找到所有的Factory.</div>
<div>A.2:  然后开始过滤， List&lt;T&gt; filtered = filter(tableFactories, factoryClass, properties)</div>
<div>        A.2.1 : 首先检查类型, TableSinkFactory.class   filterByFactoryClass(factoryClass,properties,foundFactories)</div>
<div>        A.2.2 : 然后检查必须的配置是不是设置了, List&lt;T&gt; contextFactories = filterByContext(factoryClass,properties,foundFactories,classFactories);</div>
<div>                    其中必备的配置是在factory里配置和定义的，必须不能为空.这个是有TableFactory的requiredContext()方法定义的.</div>
<div>       A.2.3 : 经过以上两轮的过滤，然后再继续检查，依然是TableFactoryService.java，这里面的</div>
<div>   private static &lt;T extends TableFactory&gt; List&lt;T&gt; filterBySupportedProperties(</div>
<div>            Class&lt;T&gt; factoryClass,</div>
<div>            Map&lt;String, String&gt; properties,</div>
<div>            List&lt;TableFactory&gt; foundFactories,</div>
<div>            List&lt;T&gt; classFactories) 方法</div>
<div></div>
<div>            这里主要是TableFactory里的两个方法定义的属性</div>
<div>                    Map&lt;String, String&gt; requiredContext();</div>
<div>                    List&lt;String&gt; supportedProperties();</div>
<div>            然后和用户Descriptor（如 ElasticSearch）里设置的属性匹配，其中有字符忽略大小写，星号匹配等细节，不再研究.</div>
<div></div>
<div>然后这就找到了工厂类，接下来要生成TableSink了。例如 ElasticSearch找到的就是Elasticsearch6UpsertTableSinkFactory.</div>
<div></div>
<div>第二步，生成TableSink.在ElasticSearch中，他是直接的new了一个Elasticsearch6UpsertTableSink.而这个对象又是一个StreamTableSink，这样就生成了一个StreamTableSink, 这个sink可以交给flink直接使用了。在ElasticSearch这个TableSink里，最关键的是实现了consumeDataStream，这个决定了sink的写逻辑.注意区分的是一个是StreamTableSink是给Table接口使用的，另一个是DataStreamSink是给DataStream使用的。这里是连接Table和Stream接口的地方。所以说，Table的API其实还是基于Stream的API的。</div>
<div></div>
<div></div>
<div>生成了Elasticsearch的TableSink之后，可以看到到这个类的用途是为了向es写入数据，他的作用是生成一个createSinkFunction。</div>
<div>createSinkFunction是具体的连接es，向es写入数据的逻辑，具体的实现是ElasticsearchUpsertSinkFunction的process的方法。是由ElasticsearchSinkBase发起的调用。</div>
<div></div>
<div></div>
<div></div>
<div>在写入ElasticSearch的时候，如何让_id使用数据里的指定的field的值？</div>
<div>在ES2.0之后，mapping里设置_id就被移除了这个特性。目的是为了让业务方不需要关心es的实现细节。在es connector里，他会根据你的table的primary key来生成这个_id的值。一般情况下，在append模式下，因为只是insert，所以他都是随机的。只有在update的时候，才需要根据primary key查找到元素并且进行更新。具体的实现在processUpsert方法。</div>
<div></div>
<div>        private void processUpsert(Row row, RequestIndexer indexer) {</div>
<div>            final byte[] document = serializationSchema.serialize(row);</div>
<div>            if (keyFieldIndices.length == 0) {</div>
<div>                final IndexRequest indexRequest = requestFactory.createIndexRequest(</div>
<div>                    index,</div>
<div>                    docType,</div>
<div>                    contentType,</div>
<div>                    document);</div>
<div>                indexer.add(indexRequest);</div>
<div>            } else {</div>
<div>                final String key = createKey(row);</div>
<div>                final UpdateRequest updateRequest = requestFactory.createUpdateRequest(</div>
<div>                    index,</div>
<div>                    docType,</div>
<div>                    key,</div>
<div>                    contentType,</div>
<div>                    document);</div>
<div>                indexer.add(updateRequest);</div>
<div>            }</div>
<div>        }</div>
<div></div>
<div>这个方法的关键是keyFieldIndices这个属性。如果这个属性没值，那么久不指定key，让他自动生成_id，否则就从元数据里拿到这个字段值，再拼接成_id.而这个值是由方法</div>
<div>public void setKeyFields(String[] keyNames) {} 来设置的。这个就是tablesink接口里定义的方法。这个方法可不是给业务方调用的，这个是flink框架调用的。所以你显示的调用这个方法也没用，他flink最终会覆盖掉你的配置。</div>
<div>/**</div>
<div>* Configures the unique key fields of the {@linkTable} to write.</div>
<div>* The method is called after {@linkTableSink#configure(String[], TypeInformation[])}.</div>
<div>*</div>
<div>*&lt;p&gt;The keys array might be empty, if the table consists of a single (updated) record.</div>
<div>* If the table does not have a key and is append-only, the keys attribute is null.</div>
<div>*</div>
<div>*@paramkeysthe field names of the table&#8217;s keys, an empty array if the table has a single</div>
<div>*             row, and null if the table is append-only and has no key.</div>
<div>*/</div>
<div>voidsetKeyFields(String[] keys);</div>
<div></div>
<div>说明在这里。说的很清楚了，如果是append-only的模式，传入的keys就为空，否则就用table 的 primary key. 所以你可以定义一个table，指定主键。</div>
<div></div>
<div>找了一圈发现并没有定义table 的 primary的语法，翻看flink的源码发现他是自动判断的，具体的是根据你的sql语句来判断的。</div>
<div></div>
<div>UpdatingPlanChecker.scala是一个scala的不太好看明白，具体的在.private class UniqueKeyExtractor {} 这个类里面。他的寻找方式是，如果你是group by 语句，那么group by 就是你的key.如果你是join，那就看你左边的表和你右边的表来分别递归计算。</div>
<div></div>
<div>// Output of join must have keys if left and right both contain key(s).</div>
<div>// Key groups from both side will be merged by join equi-predicates</div>
<div>val lInNames: Seq[String] = j.getLeft.getRowType.getFieldNames</div>
<div>val rInNames: Seq[String] = j.getRight.getRowType.getFieldNames</div>
<div>val joinNames = j.getRowType.getFieldNames</div>
<div>// if right field names equal to left field names, calcite will rename right</div>
<div>// field names. For example, T1(pk, a) join T2(pk, b), calcite will rename T2(pk, b)</div>
<div></div>
<div></div>
<div>总之就是，只有在聚合计算的时候才会有key, 也就是group by 后面的内容。那这不就扯了吗？ ElasticSearch connector 不就只支持插入操作了吗？</div>
<div></div>
<div></div>
<div>Ps： flink后续会支持在table schema里定义primary key, 已经提交了pr，<a href="https://github.com/apache/flink/pull/8736">https://github.com/apache/flink/pull/8736</a> 可惜现在还没有。pat ~</div>
<div></div>
<div></div>
<div></div>
<div></div>
<div></div>
<div></div>
<div></div>
]]></content:encoded>
			<wfw:commentRss>https://huster.top/htmls/704.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>flink的动态表格</title>
		<link>https://huster.top/htmls/700.html</link>
		<comments>https://huster.top/htmls/700.html#respond</comments>
		<pubDate>Thu, 17 Oct 2019 08:48:28 +0000</pubDate>
		<dc:creator><![CDATA[龙安_任天兵]]></dc:creator>
				<category><![CDATA[flink]]></category>

		<guid isPermaLink="false">https://huster.top/?p=700</guid>
		<description><![CDATA[目的： 订阅kafka的消息(kafka的消息是从postgresql来的)，将kafka的消息作为Table &#8230; <a href="https://huster.top/htmls/700.html" class="more-link">继续阅读<span class="screen-reader-text">“flink的动态表格”</span></a>]]></description>
				<content:encoded><![CDATA[<div>目的： 订阅kafka的消息(kafka的消息是从postgresql来的)，将kafka的消息作为TableSource，执行sql，将结果输出到ElasticSearch中</div>
<div></div>
<div>动态表格</div>
<div></div>
<div>    flink的概念里，stream的输入是一个insert的模式。类似于点击日志这种，是源源不断的产出的新数据。而postgresql到kafka的消息包含了insert,update和delete的操作。</div>
<div>在点击日志的概率里，如果统计点击次数，比较好理解。一种是表格不断的更新(update mode)。如果unique key第一次出现，则插入，否则做累加，类似下面这种</div>
<div><a href="https://huster.top/wp-content/uploads/2019/10/5.png"><img class="alignnone size-full wp-image-701" src="https://huster.top/wp-content/uploads/2019/10/5.png" alt="" width="850" height="370" /></a></div>
<div></div>
<div>还有一种则是基于窗口的统计，每一个窗口期插入一系列的数据，所以这个是insert模式</div>
<div><a href="https://huster.top/wp-content/uploads/2019/10/6.png"><img class="alignnone size-full wp-image-702" src="https://huster.top/wp-content/uploads/2019/10/6.png" alt="" width="872" height="350" /></a></div>
<div></div>
<div></div>
<div></div>
<div>但是在我们的场景里面，kafka里的消息不仅仅是插入的数据，还有可能是更新的数据。也就是有个维表，里面的数据在不断的更新。</div>
<div></div>
<div>那么现在就是要搞清楚一件事。如果我定义了一个Table，接受Stream data数据不断流入。如果我这个table里不存在这表数据(定义primary key)，那么他就会执行插入。否则他会执行update操作。我们写代码来试验一下这个想法， 看看是不是这样。如果没有group by 语句，你连primary key 都定义不了，也就没办法实现更新了…..所以要区分情况，如果你是上面的例子，通过group by 计算count, 因为有primary key，所以可以形成动态表格，可以自动update.如果你仅仅是接受kafka的消息，scan模式的话，由于表格没有primary key，所以是不支持update,而只支持insert的。</div>
<div></div>
<div></div>
<div>所以针对update 和 delete 还需要单独处理….</div>
<div></div>
<div></div>
<div></div>
<div>在Table convert to DataStream一章里，使用了Tuple2&lt;Boolean, Row&gt;这个数据结构来区分Reactor Mode. 其中那个Boolean//   True is INSERT, false is DELETE.</div>
<div></div>
<div></div>
<div></div>
<div></div>
]]></content:encoded>
			<wfw:commentRss>https://huster.top/htmls/700.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>flink相关 &#8211; 读入kafka数据源</title>
		<link>https://huster.top/htmls/696.html</link>
		<comments>https://huster.top/htmls/696.html#respond</comments>
		<pubDate>Thu, 17 Oct 2019 08:47:14 +0000</pubDate>
		<dc:creator><![CDATA[龙安_任天兵]]></dc:creator>
				<category><![CDATA[flink]]></category>

		<guid isPermaLink="false">https://huster.top/?p=696</guid>
		<description><![CDATA[业务代码如下 : fsTableEnv.connect(        newKafka()          &#8230; <a href="https://huster.top/htmls/696.html" class="more-link">继续阅读<span class="screen-reader-text">“flink相关 &#8211; 读入kafka数据源”</span></a>]]></description>
				<content:encoded><![CDATA[<div>业务代码如下 :</div>
<div>fsTableEnv.connect(</div>
<div>       newKafka()</div>
<div>                .version(&#8220;0.11&#8221;)</div>
<div>                .topic(&#8220;xxxx&#8221;)</div>
<div>                .property(&#8220;bootstrap.servers”,”<a href="http://newdev-kafka1.ttbike.com.cn:9092/">x</a>xxxx:xxxx&#8221;)</div>
<div>                .property(&#8220;<a href="http://group.id/">group.id</a>&#8220;,&#8221;test4444&#8221;)</div>
<div>                .startFromEarliest()//测试需要</div>
<div>)</div>
<div>        .withSchema(newSchema().schema(newTableSchema(fields, types)))</div>
<div>        .withFormat(newJson().schema(newRowTypeInfo(types, fields)))</div>
<div>        .inAppendMode()</div>
<div>        .registerTableSource(“testTable”);</div>
<div></div>
<div></div>
<div>问题是：读出来的数据总是null</div>
<div>DataStream&lt;Row&gt; table = fsTableEnv.toAppendStream(fsTableEnv.sqlQuery(&#8220;select * from testTable&#8221;),Row.class);</div>
<div>table.print();</div>
<div></div>
<div></div>
<p><span id="more-696"></span></p>
<div></div>
<div></div>
<div><a href="https://huster.top/wp-content/uploads/2019/10/3.png"><img class="alignnone size-full wp-image-697" src="https://huster.top/wp-content/uploads/2019/10/3.png" alt="" width="1810" height="219" /></a></div>
<div></div>
<div></div>
<div>Kafka.java 这个类依然是一个配置收集器，就是为了收集一堆配置，然后给后面的工厂方法使用。依然通过FactoryService找到了Kafka011TableSourceSinkFactory这个工厂类。</div>
<div></div>
<div>Kafka011TableSourceSinkFactory : 作用是为了生成Kafka011TableSource这个TableSource。</div>
<div></div>
<div>Kafka011TableSource: 这个类的主要功效还是一个TableSource除了定义了TableSchema和ReturnType，最主要的是完成了他的核心功能，getDataStream()方法</div>
<div></div>
<div>FlinkKafkaConsumerBase : 由上一步的getDataStream方法，其实是为了生成这个类。这个类是一个SourceFunction，其中弹出信息的方法是run方法，我们继续看他的run方法</div>
<div></div>
<div></div>
<div>最后跟踪定位到convert那个地方，才发现，原来解析的时候，他使用的是完整的json schema，而不是仅仅是data里的field字段，例如你传给kafka的json schema是包含了data平级的那些字段,table,operation等。而我传过去的是data里的field字段，当然就错了。</div>
<div></div>
<div>{</div>
<div>    &#8220;schema&#8221;: “44444&#8243;,</div>
<div>    &#8220;table&#8221;: &#8220;safs&#8221;,</div>
<div>    &#8220;operation&#8221;: &#8220;INSERT&#8221;,</div>
<div>    &#8220;data&#8221;: {</div>
<div>        &#8220;start_time&#8221;: &#8220;2019-10-10 23:00:00&#8221;,</div>
<div>        &#8220;end_point&#8221;: &#8220;0101000020E61000008BDEA9807B545E4062D9CC21A9313F40&#8221;,</div>
<div>        &#8220;start_point&#8221;: &#8220;0101000020E61000002250FD8348575E40C284D1AC6C1F3F40&#8221;,</div>
<div>        &#8220;user_new_id&#8221;: 1200001917,</div>
<div>        &#8220;end_adcode&#8221;: null,</div>
<div>        &#8220;end_time&#8221;: null,</div>
<div>        &#8220;distance&#8221;: null,</div>
<div>        &#8220;seat_count&#8221;: 4</div>
<div>    },</div>
<div>    &#8220;operateTime&#8221;: 1570602631926</div>
<div>}</div>
<div></div>
<div></div>
<div>跟踪调试，发现具体的是在Kafka09Fetcher的runFetchLoop方法里有一段，final T value = deserializer.deserialize(record);解析出来就出错了，就空了。继续跟踪调试，发现是在 JsonRowDeserializationSchema类的</div>
<div>@Override</div>
<div>public Row deserialize(byte[] message) throws IOException {</div>
<div>   try {</div>
<div>      final JsonNode root = objectMapper.readTree(message);</div>
<div>      return (Row) runtimeConverter.convert(objectMapper, root);</div>
<div>   } catch (Throwable t) {</div>
<div>      throw new IOException(&#8220;Failed to deserialize JSON object.&#8221;, t);</div>
<div>   }</div>
<div>}</div>
<div>这段代码里，root解析出来是好的，然后他开始convert.</div>
<div></div>
<div>private DeserializationRuntimeConverter assembleRowConverter(</div>
<div>   String[] fieldNames,</div>
<div>   List&lt;DeserializationRuntimeConverter&gt; fieldConverters) {</div>
<div>   return (mapper, jsonNode) -&gt; {</div>
<div>      ObjectNode node = (ObjectNode) jsonNode;</div>
<div>      int arity = fieldNames.length;</div>
<div>      Row row = new Row(arity);</div>
<div>      for (int i = 0; i &lt; arity; i++) {</div>
<div>         String fieldName = fieldNames[i];</div>
<div>         JsonNode field = node.get(fieldName);</div>
<div>         Object convertField = convertField(mapper, fieldConverters.get(i), fieldName, field);</div>
<div>         row.setField(i, convertField);</div>
<div>      }</div>
<div>      return row;</div>
<div>   };</div>
<div>}</div>
<div></div>
<div>其中有这么一段JsonNode field = node.get(fieldName);他拿着你的fieldName去json数据里get,因为少了一个data层，所以就出错了。</div>
<div></div>
<div></div>
<div>这个kafka的连接器的依赖也挺奇葩的 。</div>
<div><a href="https://huster.top/wp-content/uploads/2019/10/4.png"><img class="alignnone size-full wp-image-698" src="https://huster.top/wp-content/uploads/2019/10/4.png" alt="" width="1141" height="132" /></a></div>
<div></div>
<div>0.11版本依赖0.10.再依赖0.9……..让人很迷惑.</div>
]]></content:encoded>
			<wfw:commentRss>https://huster.top/htmls/696.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>flink学习笔记(一)</title>
		<link>https://huster.top/htmls/691.html</link>
		<comments>https://huster.top/htmls/691.html#respond</comments>
		<pubDate>Thu, 17 Oct 2019 08:45:30 +0000</pubDate>
		<dc:creator><![CDATA[龙安_任天兵]]></dc:creator>
				<category><![CDATA[flink]]></category>

		<guid isPermaLink="false">https://huster.top/?p=691</guid>
		<description><![CDATA[架构  什么是flink flink是一个框架或者叫流式计算引擎，他可以用来处理有界(批处理，mapReduc &#8230; <a href="https://huster.top/htmls/691.html" class="more-link">继续阅读<span class="screen-reader-text">“flink学习笔记(一)”</span></a>]]></description>
				<content:encoded><![CDATA[<div>架构</div>
<ol>
<li>
<div> 什么是flink</div>
</li>
</ol>
<div>flink是一个框架或者叫流式计算引擎，他可以用来处理有界(批处理，mapReduce)数据和无界数据。他的特点是具有内存的速度和分布式的横向扩展能力。由于是分布式的，所以他可以处理任意规模的数据。另外，他是有状态的，表现为上一步的结算结果可以为下一步使用。</div>
<div></div>
<p><span id="more-691"></span></p>
<div>有界和无界的解释，见下面的图。</div>
<div><a href="https://huster.top/wp-content/uploads/2019/10/1.png"><img class="alignnone size-full wp-image-692" src="https://huster.top/wp-content/uploads/2019/10/1.png" alt="" width="2220" height="526" /></a></div>
<ol start="2">
<li>
<div>    如何解释内存般的访问速度。</div>
</li>
</ol>
<div>是指用户的逻辑始终需要不断的访问记录的状态，而这些状态被记录在内存里，这样访问就很快。当内存放不下的时候，会固化到硬盘里。另外，会定期的异步将当前的快照存放到硬盘里，以防止任务的重启能接着上次的终止的地方继续运算。如下图所示</div>
<div><a href="https://huster.top/wp-content/uploads/2019/10/2.png"><img class="alignnone size-full wp-image-693" src="https://huster.top/wp-content/uploads/2019/10/2.png" alt="" width="2784" height="630" /></a></div>
<div>运维</div>
<div>   1. flink的时间和特点</div>
<div>    flink提供了事件事件模式，即用事件发生时自身的时间戳来进行统计。好处是计算结果一定正确，坏处是可能有延迟。也就是即使是数据到达的不及时，也要保证结果的正确性。还有一种是处理时间模式，也就是用的是事件到达工作机的机器时间作为统计时间。这样做的好处是低延迟，坏处是可能结果不是那么的准确。</div>
<div>        2. flink的checkpoint和savepoint</div>
<div>checkpoint是异步的增量的持久化的保存着，是为了机器故障的恢复。而savepoint则是为了集群的迁移，版本的升级而设计。在流式应用中，一个很大的难点是如何在线平滑的升级你的flink应用(业务代码，业务发布)。如果你的业务代码都重新发布了，那以前的计算的中间结果如何承接过来。总不能你一升级，用户的点击数就从0开始计算吧？flink使用savepoint很好的解决了这个难题。另外，还支持flink版本的平滑升级。</div>
]]></content:encoded>
			<wfw:commentRss>https://huster.top/htmls/691.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Java字节码增强应用</title>
		<link>https://huster.top/htmls/686.html</link>
		<comments>https://huster.top/htmls/686.html#respond</comments>
		<pubDate>Tue, 09 Jul 2019 12:55:59 +0000</pubDate>
		<dc:creator><![CDATA[龙安_任天兵]]></dc:creator>
				<category><![CDATA[Java学习]]></category>

		<guid isPermaLink="false">https://huster.top/?p=686</guid>
		<description><![CDATA[Java字节码增强技术 认识Instrumentation &#160; 基本用法: 方法 作用 addTra &#8230; <a href="https://huster.top/htmls/686.html" class="more-link">继续阅读<span class="screen-reader-text">“Java字节码增强应用”</span></a>]]></description>
				<content:encoded><![CDATA[<h1>Java字节码增强技术</h1>
<h1 id="N9W6r">认识Instrumentation</h1>
<p>&nbsp;</p>
<p>基本用法:</p>
<table class="lake-table" style="width: 722px;">
<colgroup>
<col width="240" />
<col width="240" />
<col width="241" /> </colgroup>
<tbody>
<tr>
<td>方法</td>
<td>作用</td>
<td></td>
</tr>
<tr>
<td>addTransformer</td>
<td>织入一段代码</td>
<td></td>
</tr>
<tr>
<td>removeTransformer</td>
<td>移除被织入的代码</td>
<td></td>
</tr>
<tr>
<td style="background-color: #ffffff;" colspan="1">retransformClasses</td>
<td style="background-color: #ffffff;" colspan="1">用于已经载入的类重新植入</td>
<td style="background-color: #ffffff;" colspan="1">Class&lt;?&gt;&#8230; classes</td>
</tr>
</tbody>
</table>
<p><span id="more-686"></span></p>
<p>其他用法:</p>
<table class="lake-table" style="width: 722px;">
<colgroup>
<col width="240" />
<col width="240" />
<col width="241" /> </colgroup>
<tbody>
<tr>
<td>方法</td>
<td>作用</td>
<td></td>
</tr>
<tr>
<td>appendToBootstrapClassLoaderSearch</td>
<td>将指定路径的jar包用bootstrapclassloader查找路径</td>
<td></td>
</tr>
<tr>
<td>getAllLoadedClasses</td>
<td>获取所有已加载的类</td>
<td></td>
</tr>
<tr>
<td style="background-color: #ffffff;" colspan="1">getObjectSize</td>
<td style="background-color: #ffffff;" colspan="1">获取指定的对象的大小</td>
<td style="background-color: #ffffff;" colspan="1"></td>
</tr>
<tr>
<td style="background-color: #ffffff;" colspan="1">isNativeMethodPrefixSupported</td>
<td style="background-color: #ffffff;" colspan="1">是否拦截本地方法</td>
<td style="background-color: #ffffff;" colspan="1"></td>
</tr>
</tbody>
</table>
<h1 id="txjJI">Permain的方式植入代码</h1>
<h2 id="5KeNr">程序测试代码</h2>
<p>&nbsp;</p>
<pre data-lang="java"><code>package huster.top;

/**
 * Created by longan.rtb on 2019/7/8.
 */
public class JavaAgentTest {

    public String helloWorld() {
        for (int i = 0; i&lt;5; i++) {
            System.out.println("Hello world!");
        }
        return "ok";
    }

    public static void main(String[] args) {
        JavaAgentTest javaAgentTest = new JavaAgentTest();
        javaAgentTest.helloWorld();
    }
}
</code></pre>
<p>&nbsp;</p>
<h2 id="5O1RN">Agent代码(permain方式)</h2>
<p>&nbsp;</p>
<pre data-lang="java"><code>package huster.top;

import java.lang.instrument.Instrumentation;

/**
 * Created by longan.rtb on 2019/7/8.
 */
public class AgentMain  {

    public static void premain(String args, Instrumentation inst) {
       System.out.println("permain has been called, arguments is : " + args);
       inst.addTransformer(new AOPImplement());
    }
}
</code></pre>
<p>&nbsp;</p>
<pre data-lang="java"><code>public class AOPImplement implements ClassFileTransformer {

    private final static String methodName = "helloWorld";

    private final static String targetClassName = "huster.top.JavaAgentTest";

   public byte[]
    transform(  ClassLoader         loader,
                String              className,
                Class&lt;?&gt;            classBeingRedefined,
                ProtectionDomain protectionDomain,
                byte[]              classfileBuffer)
            throws IllegalClassFormatException {
       className = className.replace("/", ".");
       if (!className.equals(targetClassName)) {
           //只监控需要的类
           return classfileBuffer;
       }

       CtClass ctclass = null;
       try {
           ctclass = ClassPool.getDefault().get(className);
           //只监控需要的方法
           CtMethod ctmethod = ctclass.getDeclaredMethod(methodName);
           //旧方法改个名字
           String oldMethod = methodName + "_____old____";
           ctmethod.setName(oldMethod);
           CtMethod newMethod = CtNewMethod.copy(ctmethod, methodName, ctclass, null);
           String methodBody = "{" +
                        "System.out.println(\"before called!!\");\n" +
                        "String a = " + oldMethod + "($$);\n" +
                        "System.out.println(\"after method called!!\");\n" +
                        "return a;" +
                   "}";
           newMethod.setBody(methodBody);
           ctclass.addMethod(newMethod);
           return ctclass.toBytecode();
       } catch (Exception e) {
           e.printStackTrace();
           return classfileBuffer;
       }

   }
}</code></pre>
<p>&nbsp;</p>
<p>pom.xml</p>
<p>&nbsp;</p>
<pre data-lang="java"><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;javaagent-demo&lt;/artifactId&gt;
        &lt;groupId&gt;huster.top&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;artifactId&gt;original-agent&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;javassist&lt;/groupId&gt;
            &lt;artifactId&gt;javassist&lt;/artifactId&gt;
            &lt;version&gt;3.12.1.GA&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;

    &lt;build&gt;
        &lt;finalName&gt;original-agent&lt;/finalName&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
                &lt;configuration&gt;
                    &lt;source&gt;1.8&lt;/source&gt;
                    &lt;target&gt;1.8&lt;/target&gt;
                    &lt;encoding&gt;utf-8&lt;/encoding&gt;
                &lt;/configuration&gt;
            &lt;/plugin&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
                &lt;version&gt;3.0.0&lt;/version&gt;
                &lt;configuration&gt;
                    &lt;archive&gt;
                        &lt;manifest&gt;
                            &lt;addClasspath&gt;true&lt;/addClasspath&gt;
                        &lt;/manifest&gt;
                        &lt;manifestEntries&gt;
                            &lt;Premain-Class&gt;huster.top.AgentMain&lt;/Premain-Class&gt;
                        &lt;/manifestEntries&gt;
                    &lt;/archive&gt;
                    &lt;descriptorRefs&gt;
                        &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;
                    &lt;/descriptorRefs&gt;
                &lt;/configuration&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;make-assembly&lt;/id&gt;
                        &lt;phase&gt;package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;single&lt;/goal&gt;
                        &lt;/goals&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;</code></pre>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>然后在测试代码的vm参数里增加：</p>
<p>-javaagent:/Users/longan.rtb/JavaProject/javaagentdemo/originalagent/target/original-agent-jar-with-dependencies.jar=args1;args2;args3</p>
<p>&nbsp;</p>
<p>运行结果如下：</p>
<p><a href="https://huster.top/wp-content/uploads/2019/07/123.png"><img class="alignnone size-full wp-image-687" src="https://huster.top/wp-content/uploads/2019/07/123.png" alt="" width="800" height="169" /></a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h1 id="03SBv">Attach的方式植入代码</h1>
<h2 id="7ste8">attach的程序</h2>
<p>&nbsp;</p>
<pre data-lang="java"><code>public class AttachAgent {

    public static void main(String[] args)  throws Exception {
        String pid = args[0];
        String jar = args[1];
        if (jar == null  || "".equals(jar)) {
            jar = "/Users/longan.rtb/JavaProject/javaagentdemo/originalagent/target/original-agent-jar-with-dependencies.jar";
        }
        VirtualMachine vmObj = null;
        try {
            vmObj = VirtualMachine.attach(pid);
            vmObj.loadAgent(jar,
                    "this is arguments");
        } finally {
            if (vmObj != null) {
                vmObj.detach();
            }

        }
    }
}
</code></pre>
<p>&nbsp;</p>
<h2 id="Fi6f1">agent的代码修改为</h2>
<p>&nbsp;</p>
<pre data-lang="java"><code>public class AgentMain  {

    public static void premain(String args, Instrumentation inst) {
       System.out.println("permain has been called, arguments is : " + args);
       inst.addTransformer(new AOPImplement());
    }

    //attach方式.
    public static void agentmain(String args, Instrumentation inst){
        System.out.println("444agentmain has been called, arguments is : " + args);
        System.out.println("is enable :" + String.valueOf(inst.isRetransformClassesSupported()));
        inst.addTransformer(new AOPImplement2(),true);
        try {
            inst.retransformClasses(Class.forName("huster.top.JavaAgentTest"));
        } catch (Exception e) {
            e.printStackTrace();
        }

    }
}</code></pre>
<p>&nbsp;</p>
<h2 id="LrlOT">坑1: 始终报UnsupportedOperationException错误</h2>
<p>是因为我们在植入代码的时候，使用了新增函数的方法，这种方法的是不允许的在Retrans的时候</p>
<p>* Caused by: java.lang.UnsupportedOperationException: class redefinition failed: attempted to add a method* The retransformation may change method bodies, the constant pool and attributes.* The retransformation must not add, remove or rename fields or methods, change the* signatures of methods, or change inheritance.  These restrictions maybe be* lifted in future versions.  The class file bytes are not checked, verified and installed* until after the transformations have been applied, if the resultant bytes are in* error this method will throw an exception.</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2 id="ja8jv">将attach程序打包成jar运行</h2>
<p>pom.xml</p>
<p>&nbsp;</p>
<pre data-lang="java"><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;javaagent-demo&lt;/artifactId&gt;
        &lt;groupId&gt;huster.top&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;


    &lt;artifactId&gt;attach-agent&lt;/artifactId&gt;

    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.sun&lt;/groupId&gt;
            &lt;artifactId&gt;tools&lt;/artifactId&gt;
            &lt;version&gt;1.8&lt;/version&gt;
            &lt;scope&gt;system&lt;/scope&gt;
            &lt;systemPath&gt;${java.home}/../lib/tools.jar&lt;/systemPath&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
                &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;attached&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;phase&gt;package&lt;/phase&gt;
                        &lt;configuration&gt;
                            &lt;descriptorRefs&gt;
                                &lt;descriptorRef&gt;jar-with-dependencies&lt;/descriptorRef&gt;
                            &lt;/descriptorRefs&gt;
                            &lt;archive&gt;
                                &lt;manifest&gt;
                                    &lt;mainClass&gt;huster.top.AttachAgent&lt;/mainClass&gt;
                                &lt;/manifest&gt;
                            &lt;/archive&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
&lt;/project&gt;</code></pre>
<p>&nbsp;</p>
<h2 id="Bs2jY">坑2: VirtualMachine找不到的问题</h2>
<p>需要我们在运行的时候指明tool.jar的位置</p>
<p>/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/bin/java -jar -Xbootclasspath/a:/Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home/lib/tools.jar /Users/longan.rtb/JavaProject/javaagentdemo/attachagent/target/attach-agent-1.0-SNAPSHOT-jar-with-dependencies.jar 29808</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content:encoded>
			<wfw:commentRss>https://huster.top/htmls/686.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>JVM Sandbox 源码分析（一）基础篇: Instrumentation和ClassFileTransformer作用</title>
		<link>https://huster.top/htmls/662.html</link>
		<comments>https://huster.top/htmls/662.html#respond</comments>
		<pubDate>Mon, 03 Jun 2019 12:41:44 +0000</pubDate>
		<dc:creator><![CDATA[龙安_任天兵]]></dc:creator>
				<category><![CDATA[Java学习]]></category>
		<category><![CDATA[java agent]]></category>
		<category><![CDATA[jvm sandbox]]></category>

		<guid isPermaLink="false">http://huster.top/?p=662</guid>
		<description><![CDATA[背景 jvm sandbox是一个开源项目https://github.com/alibaba/jvm-san &#8230; <a href="https://huster.top/htmls/662.html" class="more-link">继续阅读<span class="screen-reader-text">“JVM Sandbox 源码分析（一）基础篇: Instrumentation和ClassFileTransformer作用”</span></a>]]></description>
				<content:encoded><![CDATA[<h1>背景</h1>
<p>jvm sandbox是一个开源项目https://github.com/alibaba/jvm-sandbox/wiki/FIRST-MODULE，他是对java agent的一个应用，他将agent发扬光大，让你可以不用用户改代码的情况下，进行代码增强，实现AOP，切面编程的功能，非常强大。但是他的代码量其实不大，文档清晰，所以读起来不是太费劲。他最最基础和核心的功能是使用了Java 提供的 Instrumenttation和ClassFileTransformer来实现的，我们先来了解下这个两个类的API，了解他们都提供了什么功能。</p>
<p>&nbsp;</p>
<p><span id="more-662"></span></p>
<h1 id="0Pnqw">Instrumentation类用途</h1>
<p>提供Java代码增强功能。例如为了提供收集数据的功能，可以通过字节码增强技术，对类的方法进行增强。由于代码是添加的，所以他不会修改原来的状态。通过这个API，我们可以开发各种工具，例如监控的客户端，profiles，代码覆盖率分析工具以及事件的日志埋点工具。</p>
<p>有两种方式来获取Instrumentation实例。一种是在java启动的时候添加参数-javaagent将你的增强包加载进来，另外一种是使用VirtualMachine的API来进行。具体的做法是调用VirtualMachine.attach(java pid). 前者会在permain里把Instrumentation传过来，后者会在agentmain方法里把Instrumentation实例传过来。</p>
<p>一旦拿到了Instrumentation实例，你就可以在任何时候对原来的java代码进行代码增强。</p>
<h2 id="xzOdu"><span>addTransformer</span>(ClassFileTransformer transformer,<span> </span><strong>boolean<span> </span></strong>canRetransform)</h2>
<p>函数的作用是注册一段代码增强逻辑，他能对所有已定义的类生效<span>(除了通过依赖的</span><span>transformer进行定义的类?????)。当一个类被加载的时候，或者</span><span>是</span><span>redefineClasses方法被调用的时候，或者是</span><span>retransformClasses方法被调用的时候(前提是canRetransform的参数是true)，这个函数里注册的transformer就被调用了。至于transformer之间调用的顺序，则是由添加</span><span>的先后顺序来决定的的(假设有多个agent对同一个类的方法进行了增强，他们是按照先后顺序来执行的。)，可以想象一下管道命令，是一样的。</span></p>
<p><span>异常问题，值得注意的是，如果这个方法在执行的时候发生了异常，jvm不会中断，他会继续进行下一个transformer的执行。</span></p>
<p><span>重复add的问题，同一个transformer可能会被add多次，这个是不被推荐的，add多次最好new新的对象进行。</span></p>
<p>当传入的transformer是null的时候，这个方法会抛出NullPointException的异常，当canRetransform被设为true，而JVM虚拟机被设置为不可被reTransfrom的时候(参见<span>isRetransformClassesSupported方法</span>)，会抛出<span>UnsupportedOperationException异常。</span></p>
<h2 id="Gq9la"><span><br />
</span><span>addTransformer</span>(ClassFileTransformer transformer)</h2>
<p>等同于addTranformer(transformer,false);</p>
<h2 id="waQUQ"><span>removeTransformer</span>(ClassFileTransformer transformer)</h2>
<p><span>移除已注册的transformer。未来被定义的类将不会被应用这个transformer。由于类加载的多线程语义性，可能被移除的transformer还会依然生效，所以业务方在编写的时候要处理好，做好防御性编程。</span></p>
<h2 id="Mys7v"><span>isRetransformClassesSupported</span>()</h2>
<p>返回当前的JVM配置是否支持类的reTransform。这个取决于你的javaagent里manifest的配置项<span>的</span><span>Can-</span><span>Retransform-Classes配置，示例如下</span></p>
<p><span>​<span data-card-element="center" contenteditable="false"><span class="lake-image"><span class="lake-image-content lake-image-content-isvalid"><span data-role="detail" class="lake-image-detail"><span class="lake-image-meta"><img data-role="image" src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/1831/1559554109168-85b8888a-e4ed-4c7d-91bf-4ae19d1b3ece.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" />                            </span>       </span>     </span>   </span></span>​</span></p>
<h2 id="U0Gra"><span>retransformClasses</span>(Class&lt;?&gt;&#8230; classes) throws UnmodifiableClassException</h2>
<p>函数的用途是对传入的classes执行transform，一般用于agentmain的方式。因为agentmain的方式是在class已经被加载完了之后attch到jvm上的，这个时候只有通过这种方式来修改原来的类的行为。</p>
<p>所以在add的时候，canTransform设置为false的将会被忽略，只有设置为true的才会被执行。如果你的jvm的<span>Can-</span><span>Retransform-Classes被设置为false，会抛出异常。同时如果你的类有问题，可能会抛出ClassFormatError，NoClassDefFoundError，</span><span>ClassCircularityError，LinkageError异常，如果传入的是null，会报NullPointerException</span></p>
<h2 id="CcbjG">isRedefineClassesSupported();</h2>
<p><span>同</span><span>isRetransformClassesSupported，在manifest里配置的</span></p>
<p><span>​<span data-card-element="center" contenteditable="false"><span class="lake-image"><span class="lake-image-content lake-image-content-isvalid"><span data-role="detail" class="lake-image-detail"><span class="lake-image-meta"><img data-role="image" src="https://intranetproxy.alipay.com/skylark/lark/0/2019/png/1831/1559555920501-e7da66a6-082e-487b-a8e8-10a3d901fd8a.png" data-raw-src="" class="image lake-drag-image" alt="image.png" title="image.png" />                            </span>       </span>     </span>   </span></span>​</span></p>
<h2 id="vkc6n">redefineClasses(ClassDefinition&#8230; definitions) throws  ClassNotFoundException, UnmodifiableClassException;</h2>
<p>这个和retransformClasses非常的相似。也有人在openjdk里问过这个问题，http://mail.openjdk.java.net/pipermail/serviceability-dev/2008-May/000131.html，大概的解释是，retransformClasses是fix-and-continues，而redefined则是直接替换掉了。尤其是有多个agent同时工作的时候，更加推荐retransform。</p>
<h2 id="gXuF8">isModifiableClass(Class&lt;?&gt; theClass)</h2>
<p>这个类是否能够被transform，如果可以则返回true。</p>
<h2 id="QnROe">getAllLoadedClasses()</h2>
<p>获取所有被JVM加载的类，这个是诊断的好帮手</p>
<h2 id="lbkW8">getInitiatedClasses(ClassLoader loader)‘</h2>
<p>获取所有被指定的classloader加载的类，如果传入null则返回由BootstrapClassl返回的类。</p>
<h2 id="KOwfz">getObjectSize(Object objectToSize)</h2>
<p>获取一个对象消耗的空间大小</p>
<h2 id="I87RV">appendToBootstrapClassLoaderSearch(JarFile jarfile)</h2>
<p>将指定的jar包加载给BootstrapClassLoader，可以被执行多次从而加载多个jar包。查找类的时候会先去BootStrapLoader里去找，如果找不到就到这个jar包里面去找。</p>
<p>需要小心处理的是，包名不要重复。例如，在ClassLoader L里加载了一个类C，他有一个私有类是C$1，如果你的jar包里正好也有个类C$1，他会先去BootstrapClassLoader里去找，发现找到了，然后去load，接着发现没有权限，就会直接报出IllegalAccessError错误。</p>
<h2 id="D2O9z">appendToSystemClassLoaderSearch(JarFile jarfile)</h2>
<p>特性和appendToBootstrapClassLoader类似，不过区别是这个是用于SystemClassLoader的类的查找的(回忆一下双亲委派机制)。</p>
<h2 id="4Gjci">isNativeMethodPrefixSupported()</h2>
<p>是否设置了本地方法的拦截，由manifest设置的。Can-Set-Native-Method-Prefix属性，具体set native method prefix的用途参考nativeMethodPrefix()</p>
<h2 id="sdkq9">setNativeMethodPrefix(ClassFileTransformer transformer, String prefix)</h2>
<p>对本地方法进行代码增强。但是由于本地方法是没有字节码的，所以他的办法是重新定义一个同名的函数(原来native method)的名称，然后将原来的本地方法使用prefix进行重命名。</p>
<p>举例，以前有一个本地方法 native boolean foo(String x),他的做法是先将native的方法重命名，例如改成</p>
<p>native boolean wapped_foo(String x), 然后再定义一个方法叫 boolean foo(String x) { &#8212;你的代码&#8212; ; prefix_foo(x)}。为了防止重复，所以你的prefix最好考虑到方法重复的情况。</p>
<p>正常情况下，按照上面顺序执行，但是如果有问题的时候他的执行顺序分别是</p>
<ol start="1">
<li><span>method(foo) -&gt; nativeImplementation(foo)</span></li>
<li> method(wrapped_foo) -&gt; nativeImplementation(foo)</li>
<li>method(wrapped_foo) -&gt; nativeImplementation(wrapped_foo)</li>
<li> method(wrapped_foo) -&gt; nativeImplementation(foo）</li>
</ol>
<p>按照以上的顺序来尝试执行。</p>
<h1 id="XvwqP">ClassFileTransformer类用途</h1>
<p>用来让用户来实现代码增强逻辑的接口。他只有一个方法，方法的参数是原来的类的字节码以及这个类的classloader对象，返回值则是被增强之后的类的字节码。所以你的代码是通过已有的类信息，植入代码之后，形成新的代码(类的字节码)。</p>
<h2 id="0SssK"> transform（ClassLoader,ClassName,classBeingRedefined,protectionDomain,classfileBuffer）</h2>
<p>这里的来源有两个，分别是Instrumentation的两个addInstrumentation()方法。</p>
<p>这个函数被调用的时机有如下几种情况</p>
<ol start="1">
<li>这个类第一次被加载，当ClassLoader的defineClass()方法(这个方法是classloader将字节码解析成类并且放入metaspace的过程)被调用的时候，这个方法会被call</li>
<li>Instrumentation#redefineClasses被调用了这个方法的时候，这个方法也会被调用</li>
<li>Instrumentation#retransformClasses当这个方法被调用的时候，这个方法也会被调用</li>
</ol>
<p>他们的执行是按照addInstrumentation的顺序来执行的。而reTransformClasses和redefineClasses被执行的时候，他们修改的字节码是在之前已经被增强的基础上进行的。</p>
<p>例如原始方法是foo(String x), 然后在类加载的时候进行了一些增强，插入了一段代码，那么在下次retransformClasses执行，这个方法被调用的时候，增加的字节码是在上一次的基础上进行的。换句话说，classfileBuffer永远都是最后增强执行完成之后的版本。</p>
<p>关于异常和返回值。如果返回值是null，代表这次调用什么都没做，没有任何增强代码加入。他的效果和抛出异常是一样的，如果在执行这个函数的过程中抛出了异常，则代表本次调用什么都不做，和返回null值的效果是一样的。</p>
]]></content:encoded>
			<wfw:commentRss>https://huster.top/htmls/662.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Java类库设计之日志框架选择</title>
		<link>https://huster.top/htmls/657.html</link>
		<comments>https://huster.top/htmls/657.html#respond</comments>
		<pubDate>Tue, 28 May 2019 12:40:33 +0000</pubDate>
		<dc:creator><![CDATA[龙安_任天兵]]></dc:creator>
				<category><![CDATA[Java学习]]></category>

		<guid isPermaLink="false">http://huster.top/?p=657</guid>
		<description><![CDATA[Java日志框架现状 Java日志框架的故事说来话长，做过开发的一定遇到过slf4j,log4j,logbac &#8230; <a href="https://huster.top/htmls/657.html" class="more-link">继续阅读<span class="screen-reader-text">“Java类库设计之日志框架选择”</span></a>]]></description>
				<content:encoded><![CDATA[<h4>Java日志框架现状</h4>
<p>Java日志框架的故事说来话长，做过开发的一定遇到过slf4j,log4j,logback,commons-logging,log4j2。=也一定见过这些jar包，什么log4j.jar,slf4j-api.jar,slf4j-log4j12.jar,logback-classic.jar,logback-core.jar等等。以前看到他们就头大，傻傻分不清楚，到现在搞清楚了也就这么回事，可以具体看看slf4j的实现和适配是怎么做的。</p>
<p><span id="more-657"></span></p>
<p>要搞清楚他们的关系，就得从Java的log历史说起。在Java的初期，是没有好用的log系统的，只有System.out.print和System.out.println可以使用。如果要设置日志级别，指定我日志的格式，指定日志的路径。都得你业务方自己去弄。后来一个大牛就写了log4j这个东西，就是现在使用的日志框架的雏形。通过配置可以很方便的完成上面的那些难题。这个东西推出之后，受到了热烈的欢迎，成了当时日志的主流。Java官方看不下去了，“借鉴”当时的设计，很快推出了自己的日志框架，并且集成到JDK中，可惜为时已晚。</p>
<p>潘多拉的魔盒打开之后，就呈现出一股不可收拾的局面。随着日志框架越来越多，写日志就变得越来越混乱。这个时候大牛一看，不行啊，马上推出了slf4j，所谓的门面模式。这个东西只提供一个API，你使用这个API之后你背后用的是log4j还是JDK自带的已经不重要了。就算你以前用的是log4j，你也可以很容易的切换到遵循了这个规则的其他的日志框架。后来干脆另起炉灶，推出了logback，这个东西干脆直接使用的就是slf4j的api，连适配层都省了。</p>
<h4>为什么要选择一个合适的日志框架</h4>
<p>在设计SDK这种Java类库的过程中，我们总是期望用户不要配置，不要改代码，就能把我们集成到自己的系统中，对业务方的入侵越轻量越好。但是，如果用户没有对日志进行配置，我们的sdk集成到业务方系统中之后，我们sdk产出的日志就会和应用日志打印在一起。例如在spring boot的web应用中，就打印在application.log中。而且日志的级别都是统一配置的，我们无法决定和左右。这就给我们的诊断和监控带来了负担。因为监控的时候，我不可能监控所有的application.log，我只关心我的sdk是否工作正常。</p>
<p>当然这也是一种特殊的场景，如果你的SDK就是提供一种算法，其实打在应用日志里甚至控制台里也没有什么问题。但是如果你的SDK是一个中间件产品，里面有info,warn也有error.还需要对他们进行一些监控以确定你提供的服务是否正常，我们就需要自己配置我们的日志系统，而不是和业务方(用户)的使用同一套配置。正好我现在就遇到了这么个问题。</p>
<p>那如果我直接在我的SDK里依赖一个日志框架呢？比如我直接使用log4j的话，又会有什么问题呢？这样带来的后果，可能是灾难性的。因为以前经常在开发的时候，要解决jar包冲突的问题，尤其是不同的日志框架之间的冲突，弄得人痛不欲生。这种冲突往往需要非常仔细的排查，才能发现谁和谁冲突，然后把他排除掉，是非常浪费时间的行为。我们在设计SDK的肯定不希望给用户带来这么大麻烦。</p>
<h4>可选方案</h4>
<p>方案一： 直接依赖使用log4j或者logback.</p>
<p>这种方案的优点是SDK的开发很简单，直接new 一个Logger，然后setAppdener等这些就可以了。但是他带来的问题就是会给集成我们类库的业务方带来冲突的问题。如果集成类库的“宿主”应用原来使用的是logback，而你选择的是log4j，那就产生了冲突了。业务方有千万个，你无法知道他使用的到底是哪一个，对不对。和一部分人匹配就会和另外一部分冲突，顾前不顾后。</p>
<p>方案二：使用slf4j</p>
<p>这个使用起来也很方便，LoggerFactor.getLogger(&#8220;name&#8221;)就得到了Logger对象，然后就可以记日志了。但是他的问题在于，我们无法定制日志配置。必须公用用户的日志配置，包括日志的格式，滚动规则，路径都得拜托用户去配置，这是不现实的。</p>
<p>例如在dubbo中，他的日志就交给用户决定。用户需要告知dubbo自己使用的是什么日志框架，并且在xml里配置appender和日志滚动规则。</p>
<p>slf4j为什么没有提供这种能力呢？这个就是他的设计灵魂，所以他必然是不可能给你提供这个功能的，我们可以看看他的官方说明。</p>
<p>Should my library attempt to configure logging?<br />
Embedded components such as libraries not only do not need to configure the underlying logging framework, they really should not do so. They should invoke SLF4J to log but should let the end-user configure the logging environment. When embedded components try to configure logging on their own, they often override the end-user&#8217;s wishes. At the end of the day, it is the end-user who has to read the logs and process them. She should be the person to decide how she wants her logging configured.</p>
<p>很简单，他的设计哲学是说虽然你作为类库被人集成，但是系统是业务方的系统，打出来的日志也必然是业务方自己去看，跟你没有什么关系。这个当然是非常有道理的，但是我们的需求就是很小众，需要自己设定日志路径这种能力。</p>
<p>方案三： 自己写日志</p>
<p>还有一种方式自己写日志，自己open 一个file，然后将日志写入到问题中。但是这个代价就大了，不仅工作量大，而且很容易踩到坑。相当于把log4j又重新写了一遍。我也见过这种方式的，例如阿里的Eagleeye就是这么干的。</p>
<h4>最终方案： 适配宿主系统的日志框架</h4>
<p>目前我看到的最完美的做法就是阿里中间件的做法，他对宿主的日志框架进行了检测，看看他到底使用的是哪个日志框架，然后根据宿主的框架来选择自己使用哪个。目前内部的HSF和Diamond都是这么做的。而早期的configserver，则直接依赖的log4j的包。</p>
<h6>1.检测宿主系统的日志框架</h6>
<p>检测使用的是Class.forName来检测类是否存在，如果是slf4j的话<span>org.slf4j.impl.StaticLoggerBinder肯定存在的，否则他会抛出</span><span>ClassNotFoundException。而如果是log4j的话</span><span>org.apache.log4j.Level是存在的。总结如下：</span></p>
<p>slf4j : org.slf4j.impl.StaticLoggerBinder</p>
<p>log4j:org.apache.log4j.Level</p>
<p>log4j2:<span>org.apache.logging.log4j.core.Logger</span></p>
<p>否则就是找不到了，那就抛出异常或者是其他。</p>
<h6></h6>
<h6>2.获取日志对象</h6>
<p>使用宿主系统的框架来getLogger,具体的是, 这可以去翻看各个框架的API了，最方便的还属于依赖了slf4j的了。</p>
<p>slf4j:org.slf4j.LoggerFactory.<span>getLogger</span>(name)</p>
<p>log4j:LogManager.<span>getLogger</span>(name)</p>
<p>&nbsp;</p>
<h6>3. 配置自己的日志配置.</h6>
<p>如果是slf4j的话，就需要检测你拿到的logger到底是由谁实现的，才能用他的api来配置你appender.</p>
<p>logback: <span>ch.qos.logback.classic.Logger</span></p>
<p>log4j: <span>org.slf4j.impl.Log4jLoggerAdapter</span></p>
<p>log4j2: <span>org.apache.logging.slf4j.Log4jLogger</span></p>
<p>接下来，你就可以设置你日志配置了，包括怎么滚动，级别，日志路径等，例如log4j的可以这么设置:</p>
<p>//设置按天滚动</p>
<p><span style="font-family: Consolas, Monaco, monospace; font-size: 14px;">DailyRollingFileAppender</span><span style="font-family: Consolas, Monaco, monospace; font-size: 14px;"> appender = </span><span style="font-family: Consolas, Monaco, monospace; font-size: 14px;">new </span><span style="font-family: Consolas, Monaco, monospace; font-size: 14px;">DailyRollingFileAppender</span><span style="font-family: Consolas, Monaco, monospace; font-size: 14px;">();</span></p>
<p>appender.setFile(); //设置日志路径</p>
<p>loggger.setAppender(appender);//将日志配置设置进去</p>
<p>&nbsp;</p>
<p>后面你只需要用这个logger对象进行日志记录就行了 logger.info(&#8220;xxxxx&#8221;);</p>
<h6>打包不打包log4j,logback等</h6>
<p>还有一个黑科技也必须要提一下，因为你使用了log4j和logback的api来写代码，那你不能sdk里依赖这两个吧，这样不就直接冲突了吗？我们可以在写代码的时候依赖，在打包发布我们的jar包的时候把这些都剔除掉，如果java走不到这步逻辑，由于java的类是按需加载，所以也不会报错。</p>
<p>例如在slf4j的绑定的过程中，在源码里我们可以看到他使用的是<span>StaticLoggerBinder.java这个类来绑定的，但是我们在slf4j-api.jar包里，这个类是不存在的。</span></p>
<p>而且这个StaticLoggerBinder类的代码也明确说这个类不应当被打包到slf4j-api.jar：</p>
<pre><code>private StaticLoggerBinder() {
    throw new UnsupportedOperationException(
        "This code should have never made it into slf4j-api.jar");
}</code></pre>
<p>这个其实在写代码的时候，使用这些做一个占位符，然后在打包的时候将他们删除，让最终日志框架来实现。这个类可以在<span>slf4j-log4j12, slf4j-jkd14, slf4j-jcl的项目中可以找到类似的”org/slf4j/impl/StaticLoggerBinder.class”</span></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>另外，我觉得还有一种做法是使用JDK自带的java.util.logger，不过这个没有提供日志滚动的功能，用得确实不多，不知道有没有什么坑。</p>
<p>&nbsp;</p>
]]></content:encoded>
			<wfw:commentRss>https://huster.top/htmls/657.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>Java多线程知识点（下）</title>
		<link>https://huster.top/htmls/649.html</link>
		<comments>https://huster.top/htmls/649.html#respond</comments>
		<pubDate>Thu, 20 Dec 2018 11:29:20 +0000</pubDate>
		<dc:creator><![CDATA[龙安_任天兵]]></dc:creator>
				<category><![CDATA[Java学习]]></category>

		<guid isPermaLink="false">http://huster.top/?p=649</guid>
		<description><![CDATA[26） 如何写代码来解决生产者消费者问题？ 我们先尝试使用队列实现一个生产者和消费者模式。那么就需要先了解队列 &#8230; <a href="https://huster.top/htmls/649.html" class="more-link">继续阅读<span class="screen-reader-text">“Java多线程知识点（下）”</span></a>]]></description>
				<content:encoded><![CDATA[<h4><span>26） 如何写代码来解决生产者消费者问题？</span></h4>
<div>我们先尝试使用队列实现一个生产者和消费者模式。那么就需要先了解队列，队里的接口定义如下</div>
<div>    Queue.</div>
<div>         添加:</div>
<div>                  add(E element) 添加一个，如果超出了界限，则抛出异常</div>
<div>                  Offer(E element) 添加一个，如果超出了界限，则返回false</div>
<div>        获取并删除</div>
<div>                  remove() 获取并删除队头，如果队列为空，则抛出异常</div>
<div>                  Poll() 获取并删除队头， 如果队列为空，则返回null</div>
<div>        获取但不删除</div>
<div>                   element() 获取但是并不删除，如果队列为空，则抛出异常</div>
<div>                  peek() 获取但是并不删除，如果队列为空，则返回null.</div>
<div> 而阻塞队列则多了两个阻塞的方法，put 和 take，参见下表</div>
<div><img src="data:image/png;base64,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0YEHHqgLkFaU72X0DwIff/yx8tKsB8stt1yYYYYZwnHHHdc/BQ7wXD/77LOWIuD8bSncDReW5xMZleorY401Vhh++OEbLqdTEk4wwQRZVX788cfwzTffZM/coPDdcccd4Z577ikI7/SHpip9aWNR+EYeeWTVjtNwBPX0008f6BhYAt99993s9frrrx9YSey///66lcM2DpZC/qnwqquuqmnmnnvu8OSTT2ZpuDnzzDMDq9NRRx1VrQEnnHBCthf/5z//Oeywww4F8R988EHdIsJEC1HGvPPOG0YbbbQw33zzhXvvvbcgfi8/gDl4oRyxqmGVBmHiX3HFFcOYY46p/AJjo2OOOUa37y+//PIw22yzhcknn1wnYLbntt1224DyP+WUU4YLL7zQkuj1rbfeCuuss46+xwq3yiqrhFdeeUXfnXbaaWHRRRcNbC0Z4WMCP/773/9q0Lfffhu23HLLMNFEE+lKC76yJWF0+umnhz/96U9hpJFG0qCFF15Y41166aUWxa9NRAAhyBhF8G233XZh0kkn1T50yCGHZOOP4irxvZbq/Oc//wmzzjprmH322bPo22yzTddbE7LGdMgNvlzw8/333w+McZO/VI+xjKxgIlxhhRUCY78c4WLB4j+VGZVkrPO3HJK1hdc6Dtma3HnnndXthblugQUWqGsnLs+nRRZZJFx99dU6/ukrhx9+uFaYbdETTzxR761uN9xwg/Yf5P4yyyyjMuHuu+8Ov//973WbdPXVVy9QIKvJ+krIIIv222+/gij4DO+4445ZmM17xx57bJh22mm1X6N3GOGXSJtQ9v7973+HlVZaSV+RjnB2MtnexY2NeaebqF+UPjrXUUcdpX4hMNPosMMOC0wICGyECCuHNddc014HhA7WGZS8M844Q5WwDTfcMKy11lphnnnm0bAvv/xSJ35LRJ4wc7PNNgt0LDoiGrhZBVAGzzrrrIKtIPyFUEox0dLxEGKLL754uO6668JMM80UsCR89NFHVkRPX8EcPHCe32OPPVRJx58HgTB48OBwxRVXhE033VR5Bj4Qijr3dHb4zCDeaaedwsorr6wD9x//+IcOJBRuWwmSJzyEfwyio48+OrzxxhthoYUW0jAUtLvuuqtg1YSV+KmnngqLLbaYlosFGYUcJ3/4jjK377776jv+YHpnCzAlnp9//vk0yO+bhAAKOhM8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" /></div>
<div></div>
<p><span id="more-649"></span></p>
<h4><span>27） 如何避免死锁？</span></h4>
<div><span>    首先，死锁是什么。死锁发生在Java的多线程里，通常是一个线程持有了锁A，尝试获取锁B;于此同时，另外一个线程持有了锁B，尝试获取锁A。两个线程发生了循环等待的问题。</span></div>
<div>依照我的经验，我一般使用jstack来打印线程信息，然后搜索deadlock来查看生产环境下的死锁发生在什么地方。避免死锁的方法也很简单，那就是获取锁的顺序，保持一致即可。</div>
<div></div>
<div>推荐一篇文章，总结的很好 <a href="https://javarevisited.blogspot.com/2018/08/how-to-avoid-deadlock-in-java-threads.html">https://javarevisited.blogspot.com/2018/08/how-to-avoid-deadlock-in-java-threads.html</a></div>
<div></div>
<div></div>
<h4><span>28) Java中活锁和死锁有什么区别？</span></h4>
<div>    活锁还是我第一次听到，大概的意思就是讲，两个线程在竞争同一个资源的时候，都不直接获取资源，下一次获取的时候，恰好又发生了碰撞。这样，每次都在碰撞，导致总是拿不到锁。解决的办法就是重试机制的随机扰动，比如等待的时间随机一下，就不会发生总是遇到的情况。</div>
<div></div>
<div></div>
<h4><span>29） 怎么检测一个线程是否拥有锁？</span></h4>
<div><span>        如何检验一个线程是否拥有锁，正确的办法是在Thread上有一个方法holdLocks（Object o） 可以判断。其实我觉得这个老外的方法也挺有意思的，他是怎么做的呢？他会调用object的wait方法，如果当前线程没有锁，会抛出</span><span>IllegalMonitorStateException，通过检验这个异常就可以了。</span></div>
<div></div>
<h4><span>30) 你如何在Java中获取线程堆栈？</span></h4>
<div><span>    当然是使用Jstack命令来查看当前JVM中的所有线程的情况。同样的java/bin目录下还有很多工具</span></div>
<div></div>
<div>
<div></div>
<table>
<colgroup>
<col />
<col /></colgroup>
<tbody>
<tr>
<td>
<div>jstack</div>
</td>
<td>查看线程、死锁等情况</td>
</tr>
<tr>
<td>
<div>jstat</div>
</td>
<td>查看gc和内存情况</td>
</tr>
<tr>
<td>
<div>jmap</div>
</td>
<td>可以打印堆信息dump</td>
</tr>
</tbody>
</table>
<h4><span>31) JVM中哪个参数是用来控制线程的栈堆栈小的</span></h4>
<div>     可以调整堆大小、gc算法、伊甸区空间大小等参数</div>
<h4><span>32） Java中synchronized 和 ReentrantLock 有什么不同？</span></h4>
<div>     前者是一个隐式的锁，比较重。后者是一个可重入锁，用户可以操控，决定什么时候加锁，什么时候解锁，更加灵活。</div>
<div>而且后者的实现方式是CAS的方式具有更好的性能。尤其提供的读写锁的分离，更加灵活高效。</div>
<h4><span>33） 有三个线程T1，T2，T3，怎么确保它们按顺序执行？</span></h4>
<div>    这个其实就是考的是线程间的通信，所以你往线程的通信上去考虑就对了。比如我们的线程同步工具能不能？wait和notify能不能行？我能想到4中办法。</div>
<div>第一种，一个线程等待另外一个线程最简单的办法当时然join方法。在T3里start T2,并且调用T2的join方法可以保证T3等待T2完成。同样的办法在T2里start线程T1，T2就会等待T1完成。</div>
<div>第二种，线程间的通信，通过wait和notify实现。在T3中调用wait，并且在T2里完成了以后调用notify，通知T3线程醒来。同样的道理完成T2等待T1。不过这有个问题就是假唤醒的问题，需要特别处理下。</div>
<div>第三种，使用CountdownLatch。T3和T2公用一个，把计数器设置成1，并且在T2完成之后调用countdown的方法减一，保证T3能在T2完成之后被唤醒。</div>
<div>第四种，使用semaphore。 T3和T2公用一个，在T3里调用tryAcquire，在T2里调用release方法，保证T2完成之后可以唤醒T3线程。</div>
<div>第五种，歪门邪道。使用sleep方案。让T1,T2,T3能sleep不同的时间，当然还需要保证他们的sleep是同时开始的。如何保持同时开始呢，使用cyclicBarrier。</div>
<h4><span>34) Thread类中的yield方法有什么作用？</span></h4>
<div><span>调用这个会出让当前线程的cpu使用权，让大家在一起去竞争cpu资源，当然他自己有可能会再次抢到这个cpu资源，没有用过，不知道具体的使用场景。</span></div>
</div>
<div></div>
<div></div>
<h4><span>35） Java中ConcurrentHashMap的并发度是什么？</span></h4>
<div><span>    hashmap为什么不是线程安全的？这个要从他的实现讲起。hashmap的存储结构是一个数组结构，而当发生碰撞的时候，相同的槽位上的元素是以链表的形式组织的。线程不安全发生在扩容的时候（负载因子饱和之后），因为多个线程共享了数组的指针，导致了循环链表。当下一次读取的时候，因为循环链表就造成了死循环，cpu100%的问题。concurrentmap的解决办法是，使用了分段锁来保证线程安全和性能的问题。在jkd8里面更是采用了红黑树的存储结构来代替链表的数据结构。这个并发度其实就是初始的时候的这个数组的大小，默认是16.</span></div>
<div></div>
<h4><span>36） Java中Semaphore是什么？</span></h4>
<div>semaphore实际上就是并发量的控制。他有一个方法是tryAcquire和release。我们在执行代码之前，试着tryAcquire的话，如果当前的信号量过大，就会阻塞当前线程。知道其他线程调用了release，释放了名额，被阻塞的线程会被自动唤醒，继续自己的工作。实际上是多线程间的同步工具，其他工具如</div>
<div>
<div></div>
<table>
<colgroup>
<col />
<col />
<col /></colgroup>
<tbody>
<tr>
<td>CountdownLatch</td>
<td>
<div>await</div>
<div>Countdown</div>
</td>
<td>计数器用的，当计数器Countdown调用之后，-1， 当达到0的时候，就会唤醒所有调用了await的线程</td>
</tr>
<tr>
<td>
<div><span>CyclicBarrier</span></div>
</td>
<td>await</td>
<td>计数器用的，当达到他所设置的size之后，所有wait的线程会被唤醒</td>
</tr>
<tr>
<td>
<div><span>semaphore</span></div>
</td>
<td>
<div>tryAcquire</div>
<div>release</div>
</td>
<td>计数器用的，release之后-1，当达到限额之后，所有的tryAcquire会阻塞当前线程，知道有线程释放release之后，再唤醒大家来争抢。跟Countdownlatch的区别是他可以反复使用。</td>
</tr>
<tr>
<td>
<div>phaser</div>
</td>
<td>
<div><span>arriveAndAwaitAdvance</span></div>
</td>
<td>多阶段执行，可以定义n个阶段<span>，使</span><span>用</span><span>arriveAndAwaitAdvance这个方法可以让第一个阶段全部执行完成后，在同时进入下一个阶段</span></td>
</tr>
</tbody>
</table>
<h4><span>37）如果你提交任务时，线程池队列已满。会时发会生什么？</span></h4>
<div>    在线程池执行的时候，如果任务来的过快过多，这么多线程都来不及处理这些任务，那么来不及处理的任务会进入一个等待队列，等待线程来执行他。如果线程池的队列满了，会抛出rejectexecutorExcption。</div>
</div>
<h4><span>38) Java线程池中submit() 和 execute()方法有什么区别？</span></h4>
<div>    这个比较容易，execute是Executor接口里定义的方法，他接受的参数是Runable的接口，而submit则是ExecutorService接口里提供的方法，他是有返回对象的，返回的是Future对象，他接受的参数是Callable的对象。Future可以判断当前的任务是否完成(isDone)，并且调用ge会阻塞一直到结果返回。</div>
<div></div>
<h4><span>39) 什么是阻塞式方法？</span></h4>
<div>    阻塞方法是指方法调用之后，在该方法返回之前程序会一直等待知道有结果返回。对应的非阻塞方法是调用之后，不用等方法返回，该线程会接着做其他的事情。</div>
<h4><span>40) Swing是线程安全的吗？ 为什么？</span></h4>
<div>    略。对swing的确了解不多，而且这个技术也过时了。</div>
<div></div>
<div>
<h4><span>41） Java中invokeAndWait 和 invokeLater有什么区别？</span></h4>
<div> swing相关，暂无</div>
<h4><span>42) Swing API中那些方法是线程安全的？</span></h4>
<div><span>swing相关暂无</span></div>
<div></div>
<h4><span>44） Java中的ReadWriteLock是什么？</span></h4>
<div><span>Java的读写锁是为了读写分离使用的，先说如果没有读写锁，那么在一个读多写少的系统里，每一次读都要去竞争一把锁，但是实际上并没有人写，单纯的读是线程安全的。如果有了读写锁，在读的时候去拿读锁，再写的时候去拿读写锁。</span></div>
<div><span>    具体的使用是read的时候，getReadLock并且去lock，读完了以后unlock</span></div>
<div><span>    同理，write的时候，getWriteLock并且去lock，用完了unlock。</span></div>
<div><span>具体的实现是，read获取锁的前提是没有占用写锁，否则直接获取读锁，如果有写锁则进入等待队列。</span></div>
<div><span>如果这个时候，没有写锁，而队里里有等待写锁的线程，那么这个请求也会被放入等待队列，否则写锁永远得不到机会。</span></div>
<div><span>write获取锁的前提是，没有占用读锁，否则进入队尾等待。当读锁全部释放了以后，写锁获得，然后写数据。</span></div>
</div>
]]></content:encoded>
			<wfw:commentRss>https://huster.top/htmls/649.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>如何写代码来解决生产者消费者问题？</title>
		<link>https://huster.top/htmls/645.html</link>
		<comments>https://huster.top/htmls/645.html#respond</comments>
		<pubDate>Tue, 04 Dec 2018 12:08:09 +0000</pubDate>
		<dc:creator><![CDATA[龙安_任天兵]]></dc:creator>
				<category><![CDATA[Java学习]]></category>
		<category><![CDATA[Java]]></category>
		<category><![CDATA[多线程]]></category>
		<category><![CDATA[队列]]></category>
		<category><![CDATA[阻塞队列]]></category>

		<guid isPermaLink="false">http://huster.top/?p=645</guid>
		<description><![CDATA[这个题目考验的实际上是线程间的通信和同步问题。我们再有一篇文章中，使用Object的wait和notify实现 &#8230; <a href="https://huster.top/htmls/645.html" class="more-link">继续阅读<span class="screen-reader-text">“如何写代码来解决生产者消费者问题？”</span></a>]]></description>
				<content:encoded><![CDATA[<p>这个题目考验的实际上是线程间的通信和同步问题。我们再有一篇文章中，使用Object的wait和notify实现了线程间的同步。参见 : https://huster.top/htmls/615.html</p>
<p><span id="more-645"></span></p>
<p>一、最简单的一个实现</p>
<p>1. 生产者</p>
<pre lang="java">public class ProductClient implements Runnable {

    private Queue<string> names ;


    public ProductClient(Queue<string> names) {
        this.names = names;
    }

    public void run() {
        this.startProducter();
    }
    private void startProducter() {
        ScheduledExecutorService executorService  = Executors.newScheduledThreadPool(3);
        executorService.scheduleAtFixedRate( () -&gt; {
            SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            //有失败和丢失的可能性
            names.offer("test - " + simpleDateFormat.format(new Date()));
        }, 1, 1, TimeUnit.SECONDS);
    }

}
</string></string></pre>
<p>2. 消费者</p>
<pre lang="java">public class ConsumerClient implements Runnable {
    private Queue<string> names;

    public ConsumerClient(Queue<string> names) {
        this.names = names;
    }

    public void run() {
           while (true) {
            String name  = names.poll();
            if (name != null) {
                System.out.println("finish : " + name);
            }
        }
    }
}
</string></string></pre>
<p>3. 主程序</p>
<pre lang="java">public class MainClass {

    public static void main(String[] args) {
        Queue<string> queue = new LinkedList&lt;&gt;();
        ProductClient productClient = new ProductClient(queue);
        Thread thread = new Thread(productClient);
        Thread thread2 = new Thread(productClient);
        thread.start();
        thread2.start();
        ConsumerClient consumerClient = new ConsumerClient(queue);
        Thread consumer = new Thread(consumerClient);
        consumer.start();
        Thread consumer2 = new Thread(new ConsumerClient(queue));
        consumer2.start();
    }
}

</string></pre>
<p>分析代码，我们知道，在生产者中，我们使用一个定时任务，每隔一秒钟，就生成一个名字。而在消费者，我们使用一个while循环来不断的check是否有心的name到达，如果有，则取出，然后打印。<br />
缺点： 这个程序的缺点，显而易见，在生产者中，一旦有界队列的空间不足够，offer是可能失败的，这样就丢失了信息。而在消费者中，也有问题，while不断的在运行，但是如果queue为空的话，他其实是在空转的。他无法感知到队列的情况。</p>
<p>二、 针对以上情况，我们做一个补救措施，并且使用object的wait和notify来在线程之间进行同步。<br />
1. 生产者2</p>
<pre lang="java">public class ProductClient2 implements Runnable {
    private Queue<string> names ;
    private Object object;
    public ProductClient2(Queue<string> names, Object o) {
        this.names = names;
        this.object = o;
    }
    public void run() {
        this.startProducter();
    }
    private void startProducter() {
        ScheduledExecutorService executorService  = Executors.newScheduledThreadPool(3);
        executorService.scheduleAtFixedRate( () -&gt; {
            SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            //注意是while不是if
            while (names.size() &gt;= Integer.MAX_VALUE) {
                synchronized (object) {
                    try {
                        object.wait();
                    } catch (InterruptedException e) {
                        System.err.println(e.getMessage());
                    }

                }
            }
            names.offer("test - " + simpleDateFormat.format(new Date()));
            object.notifyAll();
        }, 1, 1, TimeUnit.SECONDS);
    }

}
</string></string></pre>
<p>2. 消费者2</p>
<pre lang="java">public class ConsumerClient2 implements Runnable {
    private Queue<string> names;

    private Object object;

    public ConsumerClient2(Queue<string> names, Object object) {
        this.names = names;
        this.object = object;
    }

    public void run() {
        while (true) {
            //注意是while not if
            while (names.size() &lt;= 0) {
                synchronized (object) {
                    try {
                        object.wait();
                    } catch (InterruptedException e) {
                        System.err.println(e.getMessage());
                    }
                }
            }
            String name  = names.poll();
            object.notifyAll();
            System.out.println("finish : " + name);
        }
    }
}
</string></string></pre>
<p>分析和总结： 这段代码解决了越界和空转的问题，但是有问题吗？仔细想想看，在Object的notifyAll的时候，当放入了元素来通知消费者的时候，一定唤醒的是消费者吗？ 不然，有可能生产者被唤醒了，而消费者却没有被唤醒。是不是有这个问题？<br />
ps : 需要注意的是，使用的是while而不是if，就是为了解决假唤醒的问题。<br />
三、 使用ReentrantLock的实现<br />
为了解决二中带来的乱唤醒的问题，我们继续优化程序如下</p>
<p>1. 生产者3</p>
<pre lang="java">public class ProductClient3 implements Runnable {
    private Queue<string> names ;
    private ReentrantLock lock;
    private Condition full;
    private Condition empty;

    public ProductClient3(Queue<string> names, ReentrantLock lock, Condition full, Condition empty) {
        this.names = names;
        this.lock = lock;
        this.full = full;
        this.empty = empty;
    }

    public void run() {
        this.startProducter();
    }
    private void startProducter() {
        ScheduledExecutorService executorService  = Executors.newScheduledThreadPool(3);
        executorService.scheduleAtFixedRate( () -&gt; {
            SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            //注意是while不是if
            while (names.size() &gt;= Integer.MAX_VALUE) {
                lock.lock();
                    try {
                        full.await();
                    } catch (InterruptedException e) {
                        System.err.println(e.getMessage());
                    } finally {
                        lock.unlock();
                    }

            }
            names.offer("test - " + simpleDateFormat.format(new Date()));
            empty.signal();
        }, 1, 1, TimeUnit.SECONDS);
    }

}
</string></string></pre>
<p>2. 消费者3</p>
<pre lang="java">public class ConsumerClient3 implements Runnable {
    private Queue<string> names;
    private ReentrantLock lock;
    private Condition full;
    private Condition empty;

    public ConsumerClient3(Queue<string> names, ReentrantLock lock, Condition full, Condition empty) {
        this.names = names;
        this.lock = lock;
        this.full = full;
        this.empty = empty;
    }

    public void run() {
        while (true) {
            //注意是while not if
            while (names.size() &lt;= 0) {
                lock.lock();
                    try {
                        empty.await();
                    } catch (InterruptedException e) {
                        System.err.println(e.getMessage());
                    } finally {
                        lock.unlock();
                    }
                }
            String name  = names.poll();
            full.signal();
            System.out.println("finish : " + name);
        }
    }


}
</string></string></pre>
<p>我们将empty和full分开考虑，这样就能确保正确的唤醒。</p>
<p>四、 终极态，使用阻塞队列。</p>
<p>到3其实我们的阻塞队列的方式呼之欲出。我们先看看阻塞队列的定义。<br />
public interface BlockingQueue<e> extends Queue<e><br />
其中Queue定义如下<br />
添加:<br />
</e></e></p>
<ol>
<li><e><e>add(E element) 添加一个，如果超出了界限，则抛出异常</e></e></li>
<li><e><e>Offer(E element) 添加一个，如果超出了界限，则返回false</e></e></li>
</ol>
<p><e><e>获取并删除</e></e></p>
<ol>
<li><e><e>remove() 获取并删除队头，如果队列为空，则抛出异常</e></e></li>
<li><e><e>Poll() 获取并删除队头， 如果队列为空，则返回null</e></e></li>
</ol>
<p><e><e><br />
获取但不删除</e></e></p>
<ol>
<li><e><e>element() 获取但是并不删除，如果队列为空，则抛出异常、</e></e></li>
<li><e><e>peek() 获取但是并不删除，如果队列为空，则返回null.</e></e></li>
</ol>
<p>而阻塞队列则多了两个阻塞的方法，put 和 take，参见下表</p>
<table>
<thead>
<tr>
<th><em>hrows exception</em></th>
<th><em>Special value</em></th>
<th><em>Blocks</em></th>
<th><em>Times out</em></th>
</tr>
</thead>
<tbody>
<tr>
<td>Insert</td>
<td>add(e)</td>
<td>offer(e)</td>
<td>put(e)</td>
<td>offer(e, time, unit)</td>
</tr>
<tr>
<td>Remove</td>
<td>remove()</td>
<td>poll()</td>
<td>take()</td>
<td>poll(time, unit)</td>
</tr>
<tr>
<td>Examine</td>
<td>element()</td>
<td>peek()</td>
<td><em>not applicable</em></td>
<td><em>not applicable</em></td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>最终实现如下</p>
<p>1. 生产者</p>
<pre lang="java">
public class ConsumerClient4 implements Runnable {
    private BlockingDeque<String> names;

    public ConsumerClient4(BlockingDeque<String> names) {
        this.names = names;
    }
    public void run() {
        while (true) {
            try {
                String name  = names.take();
                System.out.println("finish : " + name);
            }catch (InterruptedException e) {
                System.out.println(e.getMessage());
            }
        }
    }
}

</pre>
<p>2. 消费者</p>
<pre lang="java">
public class ProductClient4 implements Runnable {
    private BlockingDeque<String> names ;

    public ProductClient4(BlockingDeque<String> names) {
        this.names = names;
    }

    public void run() {
        this.startProducter();
    }
    private void startProducter() {
        ScheduledExecutorService executorService  = Executors.newScheduledThreadPool(3);
        executorService.scheduleAtFixedRate( () -> {
            SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
            try {
                names.put("test - " + simpleDateFormat.format(new Date()));
            } catch (InterruptedException e) {
                System.err.println(e.getMessage());
            }
        }, 1, 1, TimeUnit.SECONDS);
    }

}

</pre>
<p>总结: 程序瞬间短了很多有么有，其实细看阻塞队列的实现，跟我们的第三种实现基本一样，我们看下ArrayBlockingQueue的实现</p>
<pre lang="java">
 public void put(E e) throws InterruptedException {
        checkNotNull(e);
        final ReentrantLock lock = this.lock;
        lock.lockInterruptibly();
        try {
            while (count == items.length)
                notFull.await();
            enqueue(e);
        } finally {
            lock.unlock();
        }
    }

  private void enqueue(E x) {
        // assert lock.getHoldCount() == 1;
        // assert items[putIndex] == null;
        final Object[] items = this.items;
        items[putIndex] = x;
        if (++putIndex == items.length)
            putIndex = 0;
        count++;
        notEmpty.signal();
    }
</pre>
<p>基本一样，有没有。</p>
<p>五、 其他实现，诸如，我们还可以使用Semaphore来实现线程间的同步，所有线程间的同步工具，都可以用来实现生产者和消费者模式，但是都不如使用阻塞队列来的简单。</p>
]]></content:encoded>
			<wfw:commentRss>https://huster.top/htmls/645.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
	</channel>
</rss>
