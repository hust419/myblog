<br />
<b>Warning</b>:  Use of undefined constant LC_ARCHIVERS_OPTION - assumed 'LC_ARCHIVERS_OPTION' (this will throw an Error in a future version of PHP) in <b>/usr/share/nginx/html/wordpress/wp-content/plugins/lc-archivers/Lc-archivers.php</b> on line <b>89</b><br />
<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>HTTP/1.1阅读笔记 &#8211; 三两带走</title>
	<atom:link href="http://192.168.1.7/htmls/category/%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0/http1-1%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0/feed" rel="self" type="application/rss+xml" />
	<link>http://huster.top/</link>
	<description>(任天兵)龙安的博客</description>
	<lastBuildDate>Mon, 03 Jun 2019 12:41:44 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.10</generator>

<image>
	<url>https://huster.top/wp-content/uploads/2018/09/cropped-fish_112.18181818182px_1208536_easyicon.net_-32x32.png</url>
	<title>HTTP/1.1阅读笔记 &#8211; 三两带走</title>
	<link>http://huster.top/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>利用Etag来跟踪用户行为</title>
		<link>https://huster.top/htmls/369.html</link>
		<comments>https://huster.top/htmls/369.html#respond</comments>
		<pubDate>Tue, 27 Aug 2013 04:07:17 +0000</pubDate>
		<dc:creator><![CDATA[龙安_任天兵]]></dc:creator>
				<category><![CDATA[HTTP/1.1阅读笔记]]></category>

		<guid isPermaLink="false">http://www.longant.com/?p=369</guid>
		<description><![CDATA[本文转载自： http://www.oschina.net/translate/cookieless<a class="moretag" href="https://huster.top/htmls/369.html"> 阅读更多&#8230;</a>]]></description>
				<content:encoded><![CDATA[<p>本文转载自：</p>
<p>http://www.oschina.net/translate/cookieless-cookies?from=20130826</p>
<h3>英文原文：<a href="http://lucb1e.com/rp/cookielesscookies/" target="_blank">Cookieless cookies</a></h3>
<p><a href="http://my.oschina.net/u/143473" target="_blank">淘醒迷乐</a> 推荐于 7天前 (共 5 段, 翻译完成于 08-20)</p>
<p>&nbsp;</p>
<p>实际上是使用了Http协议的etag字段，非常巧妙，这个etags可以由我们生成，因此可以保证唯一性，然后发送给客户端，作为用户的一个标识，来跟踪用户的行为.</p>
<p><span id="more-369"></span></p>
<table>
<tbody>
<tr>
<td>
<div>有另一种方法可以跟踪用户而不使用cookies或Javascript。这种方法 <a href="http://en.wikipedia.org/wiki/HTTP_ETag#Tracking_using_ETags" target="_blank" rel="nofollow">已经被用于</a>无数网站，但几乎没人人们知道。本页解释这种方法是如何运作的，以及是如何保护你自己的。这种跟踪方式 <b>无需</b>使用:</p>
<ul>
<li>Cookies</li>
<li>Javascript</li>
<li>LocalStorage/SessionStorage/GlobalStorage</li>
<li>Flash、Java或其他组件</li>
<li>你的IP地址或是用户代理字符串（User Agent String ）</li>
<li>任何<a href="https://panopticlick.eff.org" target="_blank" rel="nofollow">Panopticlick</a>所使用的方式</li>
</ul>
<p>相反，它使用另一种存储方式，在浏览器重启的时候也可以保持持久性，这就是： <b>caching</b>.</p>
<p>即使你完全禁用cookies、关闭Javascript功能并且使用VPN，这种技术依然可以追踪到你。</p>
<p>在线示例：<a href="http://lucb1e.com/rp/cookielesscookies/" target="_blank" rel="nofollow">http://lucb1e.com/rp/cookielesscookies/</a></p>
<p>我们继续，输入一些东西然后保存。接着关闭你的浏览器再一次打开这个页面。它是不是还在那儿呢？</p>
<p>检查你的cookies，有没有？当然没有，因为它完完全全在一张假图片的校验和里，几乎没人能意识到。看到页面顶部右边的眼睛了吗？这就是我们的跟踪器。</p>
</div>
</td>
<td valign="top"></td>
</tr>
</tbody>
</table>
<div id="translate_22682">
<table>
<tbody>
<tr>
<td>
<div>
<h3>那么它是怎么运作的呢？</h3>
<p>这是一张概览图</p>
<p><img alt="" src="http://static.oschina.net/uploads/img/201308/20103442_3rMc.jpg" /></p>
<p>图片中的ETag是一种校验和。当图片改变时，校验和也会改变。所以当浏览器有图片并且知道校验和时，它可以将校验和传送给web服务器来验证。然后web服务器验证图片是否改变。如果没有，就不用重新传送图片了，省下了不少数据流量。</p>
<p>细心的读者或许已经注意到，可以这样追踪人群：浏览器发送回给服务器的信息就是它之前所接收到的（ETag）。这听起来和cookies十分相似。服务器可以给每个浏览器一个唯一的ETag，浏览器再次连接时ETag可以从数据库中找出来。</p>
</div>
</td>
<td valign="top"></td>
</tr>
</tbody>
</table>
</div>
<div id="translate_22683">
<table>
<tbody>
<tr>
<td>
<div><b>本例的技术要点（以及bug）</b><br />
为了描述它是如何不必使用Javascript就可以生效的，我必须找一些专属与你的信息，ETag除外。图片在页面加载完后加载，但只有图片包含 ETag。我要怎样在页面上显示实时信息呢？结果是在不动态刷新页面的情况下，我不能做到这一点，但动态刷新要用到Javascript，这又是我所想避 免的。这个鸡生蛋，蛋生鸡的问题引出了一些bug：<br />
&#8211; 所有能见的信息都是之前页面加载的。只有按F5可以看到新的数据。<br />
&#8211; 当你浏览一个页面而你没有ETag的时（比如匿名模式），你的session会被清空。只有重载时才能再次看到。</p>
<p>我没见过有简单的方案可以解决这些问题。当然事在人为，但不像其他网站，而且我想尽量保持代码简单并贴近现实。</p>
<p>注意在你真的要追踪用户时，这些bug一般不会存在。因为你不会想让用户知道他们在被追踪。</p>
<p><b>源代码</b><br />
什么项目没有源代码呢？ 哦对，是微软的Windows。</p>
<p><a href="https://github.com/lucb1e/cookielesscookies" target="_blank" rel="nofollow">https://github.com/lucb1e/cookielesscookies</a></p>
</div>
</td>
<td valign="top"></td>
</tr>
</tbody>
</table>
</div>
<div id="translate_22684">
<table>
<tbody>
<tr>
<td rowspan="2">
<div>
<h3>我们该怎么去阻止它?</h3>
<p>有一个方法我强烈推荐你做的就是, 任何时候你想更安全的浏览一个网页的话, 请开启一个隐私浏览窗口, 并仅使用https连接方式. 这么做能够单方面地消除形如 BREACH (最新的https攻击方式)攻击的影响, 禁止任何可能会产生的追踪cookie, 并且也能消除我在本页面所展示的缓存追踪的问题的影响, 我在网上购物的时候会使用隐私浏览模式. 在 Firefox 下(我想IE应该也是)快捷方式是 Ctrl+Shift+P, 在 Chrome 下则是 Ctrl+Shift+N.</p>
<p>除此以外, 这也取决于你的偏执级别.</p>
<p>由于缓存追踪实际上无法被侦测, 所以当前我还没有很直观的解决方法, 更因为缓存自身很有用(包括对你)并能够节省时间和金钱. 网站管理员们将会消耗更少的带宽(你可以想象一下, 终端用户最终将为这份因为更多的带宽而开具的账单埋单), 你的网页会更快加载, 尤其是在移动设备上会更加明显如果说你没有办理不限流量的4G套餐的话. 若你居住在有着高延迟, 低带宽的农村地区, 那就更糟糕了.</p>
</div>
</td>
<td valign="top"></td>
</tr>
<tr>
<td valign="bottom"></td>
</tr>
</tbody>
</table>
</div>
<p>如果你非常疑神疑鬼，最好禁用所有缓存。这会阻止任何追踪的发生，但我个人认为得不偿失。</p>
<p>Firefox插件Self-Destructing Cookies，能在你不使用浏览器一段时间后，清空你的缓存。这也许是个不用禁用缓存的好选择；你 <i>只</i>会在访问时被追踪，但他们通过看哪个IP访问哪个页面的方法早就做到了这一点，所以这种方法很合算。以后任何访问都仿佛来自另一个用户，如果所有其他的追踪方式也已经被阻止。</p>
<p>我不知道任何一款插件可以定期删除缓存（比如每72小时一次），但也许有。这对99%的用户来说会是个好主意，因为它限制追踪功能的同时，对性能影响较小。</p>
]]></content:encoded>
			<wfw:commentRss>https://huster.top/htmls/369.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>HTTP/1.1的那些状态码</title>
		<link>https://huster.top/htmls/236.html</link>
		<comments>https://huster.top/htmls/236.html#respond</comments>
		<pubDate>Wed, 16 May 2012 10:41:05 +0000</pubDate>
		<dc:creator><![CDATA[龙安_任天兵]]></dc:creator>
				<category><![CDATA[HTTP/1.1阅读笔记]]></category>
		<category><![CDATA[学习笔记]]></category>

		<guid isPermaLink="false">http://www.longant.com/?p=236</guid>
		<description><![CDATA[状态码的定义 本章定义了一系列的状态码（服务器返回的）以及它所依附的方法。一共分为以下几类： 1xx<a class="moretag" href="https://huster.top/htmls/236.html"> 阅读更多&#8230;</a>]]></description>
				<content:encoded><![CDATA[<ol>
<li>状态码的定义</li>
</ol>
<p>本章定义了一系列的状态码（服务器返回的）以及它所依附的方法。一共分为以下几类：</p>
<p>1xx：继续</p>
<p>2xx：正常</p>
<p>3xx：重定向</p>
<p>4xx：客户端错误</p>
<p>5xx：服务器端错误</p>
<p><span id="more-236"></span></p>
<p>10.1 1xx信息</p>
<p>1xx信息构成比较简单，由Status-Line和可有可无的头，然后由一个空行终结。由于1.0的版本没有定义1xx，所以，服务器对于使用1.0的客户端，不应该返回1xx码。</p>
<p>在正式接受正常响应以前，一个客户端应该准备着接受1个或是多个1xx的状态码，管他是否期望收到100. 一个客户端不期望的返回状态码会被丢弃。</p>
<p>除非客户端和代理间的连接断开了，否则，代理应该无条件转发1xx响应。哦，还有一种情况，比如代理在转发信息给客户端的时候，自己加上了Expect: 100-continue这个头域，那么他就不必转发100-continue。</p>
<p>10.1.1  100 continue 继续</p>
<p>100的意思是，服务器用于通知客户端，你的初始化请求，我已经收到，而且没有被拒绝，你可以继续的发送剩余的请求（如果你有的话，当然，如果你的请求已经完了，那么可以忽略）。当服务器处理完成的时候，需要发送最终响应。</p>
<p>10.1.2  101 协议交换</p>
<p>这个状态代表服务器将遵守客户端的请求，通过Upgrade message header来进行协议交换。 这个头域中定义了服务器要交换的对象，在结束101的空行后，将立即进行协议交换。为什么要改变协议呢？因为这样会带来好处，例如，协议版本从1.0换到1.1能带来绝对的好处。</p>
<p>10.2 2xx 成功</p>
<p>这个系列的状态表示客户端的请求已经被服务器收到、理解，并被接受。</p>
<p>10.2.1 200 ok</p>
<p>代表执行成功，当然各个方法的成功的定义不同。</p>
<p>GET 将返回一个带有信息主体的响应信息。</p>
<p>HEAD 不带信息主体的响应信息。</p>
<p>POST 将返回信息，包含了动作的结果</p>
<p>TRACE 返回一个信息包含这个请求被最后的服务器接收到。</p>
<p>10.2.2   201 创建</p>
<p>这个请求表明服务器已经按照请求成功的创建了资源，而这个刚刚创建的资源，能够被引用。他们写在返回的实体信息中，并描述了资源的特征，以便客户端能够选择一个最合适的去使用。信息的的格式在Content-Type中，服务器必须要在成功创建了以后才能返回201，表示已经成功创建，否则应该返回202（已经接受，此时创建过程可能还在进行）。在响应信息头中，应该返回ETag，用于标识刚被创建的资源etag。</p>
<p>10.2.3 202 已接受</p>
<p>202表示服务器已经接受了请求，而请求的执行还在进行中。最后的结果，有可能成功，也有可能执行的时候，才被拒绝。因此说。202是不承担责任的，他的设计的目的，主要是为了避免执行过程太长，而用户代理一直无穷的等待他的完成。当然，应该返回一个标识，告诉最后期望完成的时间，以便客户什么时候来检查执行结果。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>10.2.4 203 非权威信息</p>
<p>203表示响应信息的实体头域元信息，不能从源服务器获得，而是从本地或是从第三方取得的，虽然不是必须的，显然比发送200要更为合适。</p>
<p>10.2.5 204</p>
<p>204信息没有包含主体信息，仅仅用于更新头域的元信息。他不会改变视图（html在浏览器中的显示方式）而更新元信息的头域。由于没有body信息，因此，这样的响应实体包含一个头域，并以一个空行结束。</p>
<p>10.2.6 205 内容重置</p>
<p>服务器已经完成了请求,用户代理应该重新设置导致请求被发送的文件观点.这种应答主要是故意允许输入行动通过用户输入发生,伴随而来的是对给出形式的清理为了让用户可以轻松开始另一个输入行动.应答严禁包含任何实体.（没看明白，很绕）</p>
<p>10.2.7 206 局部内容</p>
<p>服务器对于资源已经完成了部分GET请求.请求必须包含一个范围报头区域(14.35节),指出了想要的范围,而且也有可能包含一个使请求条件化如果-范围报头区域</p>
<p>应答必须包含以下的报头区域:</p>
<p>或者是一个内容范围报头区域指出包含此现应答的范围,或者是对每个部分来说一个多部分的/字节范围的内容形式都包含内容范围报头.如果内容长度报头区域在当前应答中,那么它的值必须和实际在报文正文重传送的OCTET相匹配.</p>
<p>-日期<br />
-Etag或者内容位置,如果能够在一个200应答中对于同一个请求发送报头.<br />
-终止,缓存控制,和/或者变化,如果区域值与对于同一个变量以前发送的应答中的区域值不一样.如果206应答是一个使用强缓存确认的的如果范围请求的结果,那么应答不应该包含其他实体报头. 如果应答是一个使用弱缓存确认的的如果范围请求的结果,那么应答严禁包含其他实体报头,这么做是为了防止缓存实体正文和升级报头之间的矛盾性.否则,应答必须包含所有对同一个请求返回的200应答中的实体报头.</p>
<p>如果Etag或者上次更改的报头不严格匹配,缓存严禁将一个206请求与其他以前缓存的内容连接起来</p>
<p>一个并不支持范围和内容范围的缓存严禁缓存206(部分)应答.</p>
<p>&nbsp;</p>
<p>10.3 重新定向 3xx.</p>
<p>3xx系列的代码，代表重定向的意思。就是说，服务器告诉请求的客户端，需要进行下一步的动作。重定向的时候，不需要与用户交互就能进行，除非重新的请求方法是GET或是HEAD的时候。另外要防止死循环的重定向，一个客户端应该有检查这种事情的能力。在以前，重定向的次数有限制到5次，这个也需要注意的/</p>
<p>300 多种选择（很少用到）</p>
<p>这个响应信息，可能返回一个可选的选项，等待用户去选择。</p>
<p>301 永久移动（这个一般用于DNS中的URL记录）</p>
<p>这个响应是告诉请求的客户端，请求的资源已经被永久的移动了，并会在头域的Location中返回新的URI地址，除非特别说明，此请求是能缓存的。</p>
<p>302 发现(一般的PHP中的header函数实现的重定向会返回这个状态码)</p>
<p>请求的资源，暂时被更改了一个位置存放。与301不同的是，客户将来需要继续请求这个资源，因为他随时可能回来。。。</p>
<p>303 见其他（没用过）</p>
<p>304 没有改变（一般用户缓存）</p>
<p>如果一个客户端GET请求一个资源，并且此资源是允许访问的，但是服务器上的文档并没有改变，那么服务器响应此状态码。304不能响应信息主体，必须在头域后以空行结束。</p>
<p>此响应应该包含以下头域</p>
<p>Data</p>
<p>Etag</p>
<p>Expire、Cache-Control域。</p>
<p>305 使用代理</p>
<p>此响应信息是告诉客户端，必须使用响应信息中的代理来访问。代理地址在头域的Location中。</p>
<p>306 没用</p>
<p>用于以前的版本，现在没用使用。</p>
<p>307 临时重发</p>
<p>以上的URI需要在头域中的Location中指定，否则需要返回一个超文本提示和指向新URI的超文本链接。</p>
<p>4xx 客户端错误</p>
<p>4xx系列是说，客户端的请求有错误，除非是HEAD请求，否则应该在实体信息中，告之客户端，错误的详细信息。</p>
<p>400 错误请求</p>
<p>出现这个响应，是由于客户端的请求语法不对，客户端不应该不做改变的多次重试。</p>
<p>401 未经授权的</p>
<p>返回此状态表示，服务器需要认证用户授权，并会在头域中返回WWW-Authenticate，而客户端收到这个状态码以后，需要重新请求，并带上Authorization头域。</p>
<p>402 需要支付的</p>
<p>暂时保留</p>
<p>403 被禁止的</p>
<p>虽然服务器收到了请求，但是该请求行为被禁止了。除非是HEAD请求，服务器应该告之客户端被禁止的原因，但是如果服务器不想告之原因，应该返回404错误。</p>
<p>404 没有找到</p>
<p>简单的讲就是请求的资源不存在，而且并不清楚是暂时的还是永久的。同时，在403被禁止的时候，不想讲明原因，也应该返回404.</p>
<p>405 方法不被允许</p>
<p>请求的方法是不被允许的，而返回信息中，应该返回一个被允许的方法列表。</p>
<p>406 不可接受</p>
<p>用户客户端请求的可接受头域（如Accepted,Accepted-Charset,Accepted-Encoding或Acceepted-Language），服务器无能力返回，只好返回一个406。除非是HEAD请求，否则响应应该包含一个实体信息，此实体信息应该包含一个可得的实体特征和位置列表。</p>
<p>407 需要代理验证</p>
<p>这个跟401极其相似，不同的是，使用代理来进行认证。代理需要发送一个Proxy-Authorization的头的响应信息，然后客户端用一个带Authentication头域的请求进行重试。</p>
<p>408 请求超时</p>
<p>由于是长连接，当客户端在服务器允许等待的时间内，没有发送请求的话，会发送这么一个响应信息。</p>
<p>409 冲突（少见）</p>
<p>常见于PUT请求，等需要改变资源的时候，由于资源的冲突，导致请求无法完成。</p>
<p>410 永久的移除了</p>
<p>此响应跟404的区别是，他很确定资源被永久的移除出来，此结果可以缓存。</p>
<p>411 需要长度</p>
<p>依据字面意思，就懂了。需要客户端带上适合的content-length的头域，继续请求。</p>
<p>412 先决条件失败（不懂）</p>
<p>413 请求实体太大</p>
<p>服务器拒绝了请求，因为实体信息过大，服务器可能关闭连接，以防止客户端重试。如果只是暂时的，服务器应该返回一个Retry-After来指明什么时候可以重试。</p>
<p>414请求URI过长</p>
<p>依据字面意思，应该了解了。不长出现，主要可能是GET太长了。</p>
<p>415 请求的媒体类型不被支持</p>
<p>头域中的Content-Type 不被服务器支持</p>
<p>416 请求范围不足</p>
<p>请求中包含一个Rang域，并且头域中的Range-specificer值没有和已选资源中的extent重叠，并且头域没有包含一个If-Range请求头域。</p>
<p>417 期望失败</p>
<p>请求头域中的Expect不被服务器满足</p>
<p>5xx 服务器出现错误</p>
<p>此类状态码主要用于告之客户服务器产生了错误，除非是HEAD方法，否则应该返回一个实体和信息，告之用户是否是暂时的？</p>
<p>500 服务器内部错误</p>
<p>501 不能实现</p>
<p>当服务器不能识别请求方法，并且不支持他请求的资源的时候，这个返回比较合适。</p>
<p>502 网关坏了</p>
<p>503 服务器不可用（Service Unaviable）</p>
<p>此响应用于服务过载或者维护的时候，这个只是暂时的，至于什么时候可以重试，可以以Retry-After的头域告之用户。当服务器维护或过载时候，这个并不是必须的。如果不返回Retry-After，那么客户端处理这个响应应该跟500一样。</p>
<p>504 网关超时</p>
<p>505 HTTP版本不支持</p>
<p>此响应应该包含一个实体，描述了为什么不被支持和支持的协议版本。</p>
]]></content:encoded>
			<wfw:commentRss>https://huster.top/htmls/236.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>HTTP/1.1的那些方法</title>
		<link>https://huster.top/htmls/232.html</link>
		<comments>https://huster.top/htmls/232.html#respond</comments>
		<pubDate>Wed, 25 Apr 2012 15:47:26 +0000</pubDate>
		<dc:creator><![CDATA[龙安_任天兵]]></dc:creator>
				<category><![CDATA[HTTP/1.1阅读笔记]]></category>
		<category><![CDATA[学习笔记]]></category>

		<guid isPermaLink="false">http://www.longant.com/?p=232</guid>
		<description><![CDATA[最近没有更新是因为，时间比较紧张，另外，这几章比较繁琐，还是硬着头皮上吧，不然，老放在心里面，不踏实<a class="moretag" href="https://huster.top/htmls/232.html"> 阅读更多&#8230;</a>]]></description>
				<content:encoded><![CDATA[<p>最近没有更新是因为，时间比较紧张，另外，这几章比较繁琐，还是硬着头皮上吧，不然，老放在心里面，不踏实，而这几张是非常重要的几张，包括：方法、状态码、cache。</p>
<p><span id="more-232"></span></p>
<p>9. 方法定义</p>
<p>9.1.1 安全方法</p>
<p>在我们实现这些方法的时候，应该明白，浏览器（客户端）是代表用户在互联网上进行交互的，并且应该小心让用户明白自己的行为能够给自己或是别人带来不可预知的意义。</p>
<p>部分的，本协议已经确定了“GET”、“HEAD”方法除了获取资源外，不会带来其他的结果，因此这样的方法被认为是安全的。本协议还允许用户代理（浏览器）以特殊的方式进行诸如“POST”、“PUT”、“DELETE”这些方法，以保证能够让用户意识到这些方法的不安全性。</p>
<p>自然，当用户请求“GET”这种方法的时候，没必要规定服务器必须是无任何改变（副作用）的，实际上有些动态资源是有改变的。那么这个时候，最主要的区别是，用户端没有请求这些改变，因此用户端的内容是不能改变的。</p>
<p>9.1.2 等幂的方法</p>
<p>方法在请求N次和请求1次所产生的副作用一样的时候，我们就说这个方法是等幂的。“GET”、“HEAD”、“PUT”、“DELETE”有这样的特性， 而“OPTION”和“TRACE”不应该具有副作用，因此也是等幂的（内在的？）。</p>
<p>一个序列的请求，有可能不是等幂的，尽管这个序列中的每一个方法都是等幂的。反例：</p>
<p>在这个序列中，有一个请求的返回值依赖于另一个方法的结果，而这个结果是不定的，导致组后出现的结果是，同一个序列的请求，多次请求返回的结果不一致，那么就不是等幂的。当然，如果整个序列的执行结果总是相同的，那么这个序列也就是等幂的了。</p>
<p>因此根据，定义，一个序列，没有副作用，那么这个序列是等幂的。</p>
<p>9.2   OPTIONS方法</p>
<p>OPTIONS表明请求想得到在通过“Request-URI”建立的请求/响应链的可用的通信选项。</p>
<p>这个方法的结果，无法缓存。</p>
<p>如果这个方法带有信息实体，那么必须要在头域的Content-Type中指明媒体的类型，尽管当前，本协议中还没定义如何使用这个实体，当时在将来的扩展协议，会根据这个信息体来在服务器上制造更多的需求，另外，如果服务器不支持这个方法，将丢弃掉OPTION的信息体。</p>
<p>如果，Request-URI是*，OPTIONS将用于服务器，而不是去请求特殊的资源。由于这个方法是决定于资源的，所以这个*在“ping”或是“no-op”请求的时候，才会真正发挥作用，他除了能够测试服务器以外，毫无用途。比如，他可以测试一个代理，是不是支持HTTP/1.1</p>
<p>如果请求的资源，不是*的时候，OPTIONS将用于协议与资源通信的可用选项。</p>
<p>一个200响应，应该包含一个头域，定义了可以用于资源的通信选项，还有可能包含本协议没有提到的其他扩展选项。而信息的主题，应该包含可用的通信选项，尽管当前的协议还未定义这些选项，当时可以用于将来版本的扩展。如果响应信息，不包含主体信息（body），他的Content-Length应该为0.</p>
<p align="left">Max-Forwards请求头域可能会被用于针对请求链中特定的代理。当代理收到一个OPTINONS请求，并且请求的URI为absoluteURI的时候，而且此请求是可以转发的时候，那么此时代理就必须要检测Max-Forwards头域了，如果这个值为0，那么代理不能转发此请求，如果大于0，那么代理应该递减该值（1&#8211;）再转发此请求，而如果没有Max-Forwards头域，那么转发的时候不能包含Max-Forwards域。</p>
<p align="left">9.3 GET</p>
<p align="left">GET方法是用于获取URI的信息（以实体信息的格式），如果此资源涉及到数据生成的一个过程，那么获取的数据应该是生成的结果，而不是源数据。</p>
<p align="left">如果请求的方法包含If-Modified-Since, If-Unmodified-Since, If-Match, If-None-Match, or If-Range这些头域的话，GET将变成“条件GET”，那么就可以利用缓存，以节省网络开销。</p>
<p align="left">要知道，GET请求的结果，是可以缓存的。</p>
<p align="left">9.4 HEAD</p>
<p align="left">HEAD方法跟GET方法是一样的，唯一的不同是他不需要返回信息实体，他常用于测试链接的有效性，可访问性，以及最近是否更改。HEAD也是可以被缓存的，如果出现一个新域（Content-Length, Content-MD5, ETag or Last-Modified）表明缓存实体与服务器上不一致，那么缓存将过保质期。</p>
<p align="left">9.5 POST方法</p>
<p align="left">POST方法被设计用来请求服务器接收请求中的实体，作为一个附属物，他常用于发布一个公告、新闻组、邮件列表或者相似文章组。POST请求的实际效果是由服务器来决定的，他可能不会对URI的资源起任何改变的作用，这时候200（成功）或204(没有内容)是比较合适的返回。如果请求被创建，将返回201并且包含一个实体，描述了请求的状态。</p>
<p align="left">POST方法是不可缓存的，除非响应里有合适的的Cache-Control或者Expires头域。</p>
<p align="left">9.6 PUT</p>
<p align="left">PUT请求服务器把请求中的实体存储在URI的标识之下。如果此URI已经在服务器上存在，那么此实体，应该当作最新版本。如果请求的URI在服务器上不存在，且此URI被用户定义为一个新的资源，那么应该创建一个新的URI下标识的资源，此时服务器返回给用户201（已创建），如果已经存在的内容版本被更新了（第一种情况），应该发送200（OK）或是204响应。</p>
<p align="left">如果请求穿过一个缓存，并且此请求URI指定一个或多个实体，那么这些实体都被认为是过时的，另外PUT方法是不可缓存的。</p>
<p align="left">PUT和POST的最大区别在于URI，POST中的URI是一个能够处理请求的资源，如一个网关（网关能进行协议转换，而代理不行），而PUT方法里的URI是用于表示请求的实体，并且服务器不能将此请求用于其他的资源，如果期望用于其他资源，必须发送301（永久移动），由用户来决定是否进行一次新的请求。</p>
<p align="left">9.7 DELETE</p>
<p align="left">此方法用于请求服务器删除请求里URI指定的资源，客户不能保证此操作能够成功，尽管返回的是成功的状态，然而，既然服务器返回了成功状态，他就应该有打算删除资源，或是把他移动到一个不可用的位置。</p>
<p align="left">如果返回的结果成功，并包含了成功的实体，那么应该是200（OK），如果还没执行，应该是202（已经接受你的请求），如果方法已经执行，但是不包含实体信息，应该返回204.</p>
<p align="left">9.8 TRACE</p>
<p align="left">此方法用于激发一个远程的应用层的请求信息回路。用于测试到服务器的网络通路。最后的接收者可能是源服务器，也可能是代理（此代理必须是Max-Forwards为0）。TRACE用于客户端了解数据被请求链的另一端的接受情况，并用这些数据去诊断。Via头域，可用于跟踪信息。Max-Forwards可用于限制请求链的长度，此响应不能被缓存。</p>
<p align="left">9.9 CONNECT</p>
<p align="left">此方法暂时保留，用于动态的切刀隧道代理。</p>
<p align="left">
<p align="left">
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content:encoded>
			<wfw:commentRss>https://huster.top/htmls/232.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>HTTP/1.1之连接（第八章）</title>
		<link>https://huster.top/htmls/170.html</link>
		<comments>https://huster.top/htmls/170.html#respond</comments>
		<pubDate>Thu, 19 Apr 2012 03:50:17 +0000</pubDate>
		<dc:creator><![CDATA[龙安_任天兵]]></dc:creator>
				<category><![CDATA[HTTP/1.1阅读笔记]]></category>
		<category><![CDATA[学习笔记]]></category>

		<guid isPermaLink="false">http://www.longant.com/?p=170</guid>
		<description><![CDATA[HTTP/1.1之连接（第八章） 8.1 持久性连接 目的： 在以前，没有持久性连接的时候，为了获取<a class="moretag" href="https://huster.top/htmls/170.html"> 阅读更多&#8230;</a>]]></description>
				<content:encoded><![CDATA[<p>HTTP/1.1之连接（第八章）</p>
<p>8.1 持久性连接</p>
<p>目的：</p>
<p>在以前，没有持久性连接的时候，为了获取每一个URL都要进行一次TCP连接，这显然加重了服务器的负担，容易引起互联网的堵塞，因为你要多次进行三次握手，尤其是页面里面有很多内联的图片、css样式表、js文件时候，简直让人崩溃。所以，持久连接有以下特点：</p>
<p><span id="more-170"></span></p>
<ol>
<li>通过建立较少的TCP连接，可以节省不少路由与主机（包含服务器端和用户端）cpu利用率，而且还能节省用于tcp协议控制块的内存。</li>
<li>显然，一个连接，多次传输节省了时间开销。</li>
<li>网路阻塞会减少，因为少发了很多握手连接的数据包。</li>
<li>改进越来越优雅，错误报告，不用关闭连接，而老的必须关闭连接，然后重试新连接。</li>
</ol>
<p>8.1.2 总体操作</p>
<p>在HTTP/1.1中，持久连接应该是必须的，默认的。不需要协商都应该采用的方式。也就是，默认，客户端和服务端都是持久连接，即使服务器的错误响应，也当如此。</p>
<p>连接总要终止的，在数据发送完成以后，应该关闭。可以利用Connection的头域，发送close信息来关闭连接。</p>
<p>8.1.2.1 协商</p>
<p>主要是协商怎样断开，任何一方（用户浏览器or服务器）都可以随时选择断开连接，唯一要做的就是，在Connection头域发送一个close信息，这个信息将会是他们连接的最后一条信息。</p>
<p>8.1.2.2 管线</p>
<p>管线就是说，可以以管线的方式，发送数据，无须等待响应，而发送多条请求，服务器端必须根据信息的先后顺序来发送响应。</p>
<p>在第一次管线连接失败的时候，客户端应该去尝试重新连接，这个时候，只有确认了当前的连接是持久性连接的时候，才能发起管线连接。同时，如果服务器在发出所有的响应之前关闭了连接，这个时候，客户端还需要重新发送请求。</p>
<p>8.1.3 代理</p>
<p>代理非常重要，在4章中，我们知道，一个代理不应该改变头域的值，代理必须同时向客户端和源服务器指明持久性连接，而且，在后文中，我们可以发现，代理保持持久连接的时间要更长，因为，同一个页面，可能会有多个人来访问。</p>
<p>8.1.4 实际考虑</p>
<p>持久连接必须要有一个超时的时限，要不然，没有请求发送，双发的close信息丢失，会导致资源无法释放。代理的时间要更长的原因是，用户对同一个源服务器可能发送多个请求。</p>
<p>客户端和服务器端必须能够要优雅的协商，有没有这么一种情况 ：</p>
<p>客户端正想去发送请求的时候，服务器端，发出一个终止连接的响应（资源被闲置）。这说明，服务器和客户端必须有一个机制，能够从连接的异步事件中恢复。只要请求是等幂的，客户端软件（浏览器）应该不需要用户交互的情况下，重新发送请求。如果再次请求的序列仍然失败了，那就不再重试了。</p>
<p>8.2 信息传送的要求</p>
<p>8.2.1 持久连接与流量控制</p>
<p>持久连接的流量控制是使用TCP的流量控制来进行的。</p>
<p>8.2.2 监视连接中的错误信息</p>
<p>如果客户端与服务器端通信的过程中发生了错误，应当立即停止传送，如果是以块传送编码方式传送，则可以发送长度为0的块和空尾部来提前标记传输结束。如果先前已经发送了Content-length的话，就必须关闭连接了。</p>
<p>8.2.3 100码的用途</p>
<p>有时候，服务器闹点小情绪，人家不想看你的信息主体，这个时候再去发送信息主体，就有点让人烦躁了。所有用一个100码来探测，是否愿意继续接受主体信息。</p>
<p>HTTP/1.1 的客户端的要求：</p>
<p>如果不打算发送信息主体，就不要发送100-continue的Expect的头域，如果你想要在发送信息主体前接受到100的响应，就必须发送上述头域。由于旧实现的原因，你发送了这样的头域以后，不能无止尽的等待服务器端响应100呐，得迷途知返呐。</p>
<p>HTTP/1.1 的服务器端的要求：</p>
<p>一个服务器接收到一个100-continue的头域以后，要么就回应100请求继续发送，要么就发送最终的状态响应码，你不能在发送100之前接受信息，当然，如果你发送了最终响应码以后，就不应该再接受信息主体。要么就，接收到了以后，直接丢弃了，切不能执行GET等方法。</p>
<p>如果对方没有发送100-continue的头域，服务器就不哟啊发送100了。如果请求来自于HTTP/1.0，也不应该发送，否则那边是无法识别的。</p>
<p>一旦消息被接受，并被处理，发送100的源服务器应该要发送一个结束的响应信息，除非源服务器过早的断开了传输层的连接。</p>
<p>代理的行为规则：</p>
<p>如果代理接收到一个100-continue的头域，在不知道源服务器（或代理服务器）的http协议版本的时候，需要直接转发这个头域，如果已经知道对方是http/1.0，那么就应该去这个头域，并且返给客户端一个417（期望失败）的响应。这个版本号应该维护一个缓存。如果一个客户端的版本是HTTP/1.0，那么代理就不应该转发100的返回码。</p>
<p>服务器过早关闭的时候，客户端的请求算法：</p>
<p>如果一个客户端发送了一个带有100-continue的Expect的头域，并且，这个客户端没有直接与源服务器连接，并且他在接受到状态码前已经发现了断开了连接，这个时候，他需要重试连接。会遵循以下的过程。</p>
<ol>
<li>初始化一个新的连接。</li>
<li>发送请求头域</li>
<li>初始化一个变量值R，这个值代表了到服务器的一个回路的时间（当然是估计的），或者是直接初始化为5S。</li>
<li>T = R*(2**N) N代表重试的次数。</li>
<li>等待T秒，或者是服务器端的错误信息。</li>
<li>如果收到错误信息，T秒后，重传请求主体。</li>
<li>如果客户端提前发现连接关闭，则重复1进行重试，知道下面三种情况，一，成功的把请求发送出去了，二，收到错误信息而终止，三，用户受不了了，主动终止了重试。</li>
</ol>
<p>在任意点上，客户端如果接收到错误信息，应该立即终止连接。</p>
<p>&nbsp;</p>
<p>所谓幂等指对同一URL的多个请求应该返回同样的结果。比如sina网中点击某一个新闻页面，不同的时候返回应该是同一篇文章，如果后台有修改这条新闻，用户所看到的内容不同，但是我们还是会认为这是幂等的。</p>
]]></content:encoded>
			<wfw:commentRss>https://huster.top/htmls/170.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>HTTP/1.1阅读之信息实体</title>
		<link>https://huster.top/htmls/168.html</link>
		<comments>https://huster.top/htmls/168.html#respond</comments>
		<pubDate>Mon, 16 Apr 2012 12:18:49 +0000</pubDate>
		<dc:creator><![CDATA[龙安_任天兵]]></dc:creator>
				<category><![CDATA[HTTP/1.1阅读笔记]]></category>
		<category><![CDATA[学习笔记]]></category>

		<guid isPermaLink="false">http://www.longant.com/?p=168</guid>
		<description><![CDATA[7 信息主体 信息主体是由信息头和信息主体两部分组成的，除非被Status-code或是请求方法限制<a class="moretag" href="https://huster.top/htmls/168.html"> 阅读更多&#8230;</a>]]></description>
				<content:encoded><![CDATA[<p>7 信息主体</p>
<p>信息主体是由信息头和信息主体两部分组成的，除非被Status-code或是请求方法限制了，导致没有信息主体（为空）。我们在这章讨论的时候，发送和请求是辩证唯物的。当客户端请求服务器的时候，客户端是发送方，而服务器是接收方，但是服务器返回信息的时候，服务器是发送方，而客户端则是接收方。</p>
<pre>       entity-header  = Allow                    ; Section 14.7
                      | Content-Encoding         ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11" rel="xref">14.11</a>
                      | Content-Language         ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.12" rel="xref">14.12</a>
                      | Content-Length           ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.13" rel="xref">14.13</a>
                      | Content-Location         ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.14" rel="xref">14.14</a>
                      | Content-MD5              ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.15" rel="xref">14.15</a>
                      | Content-Range            ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.16" rel="xref">14.16</a>
                      | Content-Type             ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.17" rel="xref">14.17</a>
                      | Expires                  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.21" rel="xref">14.21</a>
                      | Last-Modified            ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.29" rel="xref">14.29</a>
                      | extension-header</pre>
<pre>       extension-header = message-header

以上实体部分，有些选项是可选的，有些则是必须的。其中的extension-header可以不用升级协议版本就可以扩展信息主体，但是你不能期望人家
接收方能够正确的识别，如果对方识别不了，这个扩展区将被忽略，但是代理转发的时候，你不能随意的忽略这个扩展区，这很好理解，因为你是代理
你又不知道人家接收方能不能识别这个扩展信息。</pre>
<pre> entity-body    = *OCTET
如果实体存在的话，他的编码方式是在信息头域的Transfer-Encoding来决定的，这东西就是用来保证信息能够被正确的传输。
如果实体信息存在的话，他们会由头域的Content-Encoding和Content-Type来确定的，这些头域定义了两层顺序的编码模型，例如：</pre>
<pre>entity-body := Content-Encoding( Content-Type( data ) )，其中前者一般用于定义使用了什么压缩方式，而后者type表示请求的是什么类型
如果没有指定，他就会去猜，实在猜不到就application/octet-stream这样了 
实体信息的长度是编码前的长度，4.4节已经定义了，如果去确定信息的长度。</pre>
]]></content:encoded>
			<wfw:commentRss>https://huster.top/htmls/168.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>HTTP/1.1阅读之响应</title>
		<link>https://huster.top/htmls/166.html</link>
		<comments>https://huster.top/htmls/166.html#respond</comments>
		<pubDate>Mon, 16 Apr 2012 11:29:34 +0000</pubDate>
		<dc:creator><![CDATA[龙安_任天兵]]></dc:creator>
				<category><![CDATA[HTTP/1.1阅读笔记]]></category>
		<category><![CDATA[学习笔记]]></category>
		<category><![CDATA[HTTP/1.1]]></category>
		<category><![CDATA[互联网]]></category>

		<guid isPermaLink="false">http://www.longant.com/?p=166</guid>
		<description><![CDATA[与上一章对应，一个响应信息的包含部分如下： Response = Status-Line ; Sec<a class="moretag" href="https://huster.top/htmls/166.html"> 阅读更多&#8230;</a>]]></description>
				<content:encoded><![CDATA[<p>与上一章对应，一个响应信息的包含部分如下：</p>
<pre> Response      =        Status-Line               ; Section 6.1
                       *(( general-header        ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.5" rel="xref">4.5</a>
                        | response-header        ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.2" rel="xref">6.2</a>
                        | entity-header ) CRLF)  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.1" rel="xref">7.1</a>
                       CRLF
                       [ message-body ]          ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.2" rel="xref">7.2</a>
其中比较重要的是Status-line行，他由以下部分组成：</pre>
<pre>Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF</pre>
<p><span id="more-166"></span></p>
<pre>
以请求行不同的是，他把version提到第一个了，接着是Status的Code信息，最后是一个原因解释。Code信息是给程序看得，Reason是给人看的。
状态码一般由一个三位数来决定的，其中，第一位数字决定了错误类型，一共有5种。
1xx表示请求正在进行中
2xx表示请求被接受了
3xx表示请求被重新定向了
4xx表示请求有问题（用户发送的请求有问题）
例如：404表示用户请求了一个不可用的资源
     上一章的405，表示用户请求了一个不被允许的方法，但是501就表示，这个方法，服务器没有被实现，对
5xx就表示服务器端的错误。
具体的如下：</pre>
<pre>      Status-Code    =
            "100"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.1.1" rel="xref">10.1.1</a>: Continue
          | "101"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.1.2" rel="xref">10.1.2</a>: Switching Protocols
          | "200"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.2.1" rel="xref">10.2.1</a>: OK
          | "201"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.2.2" rel="xref">10.2.2</a>: Created
          | "202"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.2.3" rel="xref">10.2.3</a>: Accepted
          | "203"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.2.4" rel="xref">10.2.4</a>: Non-Authoritative Information
          | "204"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.2.5" rel="xref">10.2.5</a>: No Content
          | "205"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.2.6" rel="xref">10.2.6</a>: Reset Content
          | "206"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.2.7" rel="xref">10.2.7</a>: Partial Content
          | "300"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.1" rel="xref">10.3.1</a>: Multiple Choices
          | "301"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.2" rel="xref">10.3.2</a>: Moved Permanently
          | "302"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.3" rel="xref">10.3.3</a>: Found
          | "303"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4" rel="xref">10.3.4</a>: See Other
          | "304"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5" rel="xref">10.3.5</a>: Not Modified
          | "305"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.6" rel="xref">10.3.6</a>: Use Proxy
          | "307"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.8" rel="xref">10.3.8</a>: Temporary Redirect
          | "400"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.1" rel="xref">10.4.1</a>: Bad Request
          | "401"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.2" rel="xref">10.4.2</a>: Unauthorized
          | "402"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.3" rel="xref">10.4.3</a>: Payment Required
          | "403"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.4" rel="xref">10.4.4</a>: Forbidden
          | "404"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.5" rel="xref">10.4.5</a>: Not Found
          | "405"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.6" rel="xref">10.4.6</a>: Method Not Allowed
          | "406"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.7" rel="xref">10.4.7</a>: Not Acceptable</pre>
<pre>          | "407"  ; Section 10.4.8: Proxy Authentication Required
          | "408"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.9" rel="xref">10.4.9</a>: Request Time-out
          | "409"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.10" rel="xref">10.4.10</a>: Conflict
          | "410"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.11" rel="xref">10.4.11</a>: Gone
          | "411"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.12" rel="xref">10.4.12</a>: Length Required
          | "412"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.13" rel="xref">10.4.13</a>: Precondition Failed
          | "413"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.14" rel="xref">10.4.14</a>: Request Entity Too Large
          | "414"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.15" rel="xref">10.4.15</a>: Request-URI Too Large
          | "415"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.16" rel="xref">10.4.16</a>: Unsupported Media Type
          | "416"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.17" rel="xref">10.4.17</a>: Requested range not satisfiable
          | "417"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.18" rel="xref">10.4.18</a>: Expectation Failed
          | "500"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.1" rel="xref">10.5.1</a>: Internal Server Error
          | "501"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.2" rel="xref">10.5.2</a>: Not Implemented
          | "502"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.3" rel="xref">10.5.3</a>: Bad Gateway
          | "503"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.4" rel="xref">10.5.4</a>: Service Unavailable
          | "504"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.5" rel="xref">10.5.5</a>: Gateway Time-out
          | "505"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.6" rel="xref">10.5.6</a>: HTTP Version not supported
          | extension-code</pre>
<pre>      extension-code = 3DIGIT
      Reason-Phrase  = *&lt;TEXT, excluding CR, LF&gt;
还不够！！ 这些还能够根据需要而被扩展，没准HTTP/1.2又搞出一堆其他的什么出来。然后可是，服务器端并不需要理解所有的Status-Code，尽管，
我们希望如此，如果一个Status-code未被理解，将被解释成x00，例如你来一个532，根本没这玩意儿，将被解释成500.
同样一个响应信息的头域，允许服务器返回附加信息给用户代理，他应该由以下内容组成</pre>
<pre>       response-header = Accept-Ranges           ; Section 14.5
                       | Age                     ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.6" rel="xref">14.6</a>
                       | ETag                    ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.19" rel="xref">14.19</a>
                       | Location                ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.30" rel="xref">14.30</a>
                       | Proxy-Authenticate      ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.33" rel="xref">14.33</a></pre>
<pre>                       | Retry-After             ; Section 14.37
                       | Server                  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.38" rel="xref">14.38</a>
                       | Vary                    ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.44" rel="xref">14.44</a>
                       | WWW-Authenticate        ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.47" rel="xref">14.47</a>
当然，一个未被识别的响应头域，将被看错信息头域。
</pre>
<pre></pre>
]]></content:encoded>
			<wfw:commentRss>https://huster.top/htmls/166.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>HTTP/1.1阅读之请求</title>
		<link>https://huster.top/htmls/163.html</link>
		<comments>https://huster.top/htmls/163.html#respond</comments>
		<pubDate>Mon, 16 Apr 2012 11:13:40 +0000</pubDate>
		<dc:creator><![CDATA[龙安_任天兵]]></dc:creator>
				<category><![CDATA[HTTP/1.1阅读笔记]]></category>
		<category><![CDATA[学习笔记]]></category>
		<category><![CDATA[HTTP/1.1]]></category>

		<guid isPermaLink="false">http://www.longant.com/?p=163</guid>
		<description><![CDATA[5.1 请求消息的构成 在上一章，我们知道一个请求的消息应该由以下几部分组成： Request = <a class="moretag" href="https://huster.top/htmls/163.html"> 阅读更多&#8230;</a>]]></description>
				<content:encoded><![CDATA[<p>5.1 请求消息的构成</p>
<p>在上一章，我们知道一个请求的消息应该由以下几部分组成：</p>
<pre> Request       = Request-Line              ; Section 5.1
                 *(( general-header        ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.5" rel="xref">4.5</a>
                 | request-header         ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.3" rel="xref">5.3</a>
                 | entity-header ) CRLF)  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.1" rel="xref">7.1</a>
                        CRLF
                 [ message-body ]          ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3" rel="xref">4.3</a>
他们是请求头（由请求行、一般头、请求头和信息头）+信息主体构成。我们来看看请求行（Request-Line），他是由下面几部分构成的：
Method sp URI sp HTTP-Version CRLF,我们来像教科书一样，看看各个部分都是干啥的</pre>
<p><span id="more-163"></span></p>
<pre>
5.1.2 方法（Method）
请求的方法一共有以下几种：</pre>
<pre> Method         =     "OPTIONS"                ; Section 9.2
                      | "GET"                    ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.3" rel="xref">9.3</a>
                      | "HEAD"                   ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.4" rel="xref">9.4</a>
                      | "POST"                   ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.5" rel="xref">9.5</a>
                      | "PUT"                    ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.6" rel="xref">9.6</a>
                      | "DELETE"                 ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.7" rel="xref">9.7</a>
                      | "TRACE"                  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.8" rel="xref">9.8</a>
                      | "CONNECT"                ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.9" rel="xref">9.9</a>
                      | extension-method
       extension-method = token
上图的意思是：OPTION是可选的（有那么多种），然后加上Token，我们比较熟悉的是GET、POST、HEAD方法。
源服务器一般将这边能够接受的请求方法写在 Allow header field 这个域中，然后在返回的信息中通知到客户端，因为这些被允许的方法并不是一成不变的。
如果一个方法是在列表，但是又没有允许的情况下，源服务器会返回405错误，如果完全不支持则返回501错误，这以上列表的方法中，GET和HEAD是必须能够支持的。

<a id="sec5.1.2">5.1.2</a> Request-URI</pre>
<pre>Request-URI    = "*" | absoluteURI | abs_path | authority 
统一资源定位符，由以上四种形式构成，他会是他们其中的一种，他是用来定位资源的具体位置的。
其中×定位符，表示这个请求并不定位到具体的资源，他在乎的仅仅是服务器本身，但是必须是方法不应用一个资源时。真心不知道他说的啥意思，平时太少见了。
注意的是，使用代理访问的时候，发给代理的请求必须是absoluteURI这种格式的，代理可以根据需要从cache直接返给用户，或者是将请求发给源服务器。需要
注意的是，代理有可能再发给另外一个代理服务器（不是源服务器），或者直接访问源服务器。为了避免代理间的循环请求。例如，有ABC三个代理，A从B拿数据，B
又从C拿数据，C从A拿数据，这就形成了一个循环（我的理解如此），那么为了避免这个问题，代理必须要能识别出服务器的名字，不管你使用的是别名、数字ip还
是别的啥玩意儿，这样，ABC三个人都互相认识，也就不会出现循环了。一个完整的Reques-line如下：</pre>
<pre> GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.1
所有的HTTP/1.1的服务器，必须能够接受和处理absoluteURI地址</pre>
<pre>authority 这种形式，只能用于CONNECT方法。
对于我们来说，大部分访问是向源服务器或是网管请求的，这时候，Request-URI必须表现成abs_path的形式，而这个时候的网络主机信息就必须以头域里的host轮胎体现了
举例来说，一个访问主机host的请求类似于：</pre>
<pre>  GET /pub/WWW/TheProject.html HTTP/1.1
       Host: www.w3.org
必须注意的是，第一行abs_path是不能缺少的，如果空的时候，应该写成“/”表示网站的根目录
一个透明代理是不应该更改abs_path的，除非是把空的改写成"/"。
如果是以absoluteURI 的形式来进行请求的，那么头域的host信息会被忽略。如果不是这种形式以外的其他形式，应该以头域的host域为准，如果host无效
会返回400错误。（坏请求）
缺少头域的host的http/1.0的请求，可能会使用启发是规则，就是去看，是不是特定的主机。
5.3 请求头域
请求头域能够让客户端添加附件的信息，来告之服务器。其中信息如下：</pre>
<pre>       request-header = Accept                   ; Section 14.1
                      | Accept-Charset           ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.2" rel="xref">14.2</a>
                      | Accept-Encoding          ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3" rel="xref">14.3</a>
                      | Accept-Language          ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4" rel="xref">14.4</a>
                      | Authorization            ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.8" rel="xref">14.8</a>
                      | Expect                   ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.20" rel="xref">14.20</a>
                      | From                     ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.22" rel="xref">14.22</a>
                      | Host                     ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.23" rel="xref">14.23</a>
                      | If-Match                 ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.24" rel="xref">14.24</a></pre>
<pre>                      | If-Modified-Since        ; Section 14.25
                      | If-None-Match            ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.26" rel="xref">14.26</a>
                      | If-Range                 ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.27" rel="xref">14.27</a>
                      | If-Unmodified-Since      ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.28" rel="xref">14.28</a>
                      | Max-Forwards             ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.31" rel="xref">14.31</a>
                      | Proxy-Authorization      ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.34" rel="xref">14.34</a>
                      | Range                    ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35" rel="xref">14.35</a>
                      | Referer                  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.36" rel="xref">14.36</a>
                      | TE                       ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.39" rel="xref">14.39</a>
                      | User-Agent               ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43" rel="xref">14.43</a>

这些个东西，是能够被扩展的。随着HTTP协议版本的增加，可能会增加新的东东，但是如果所有通信方都把他看做请求头域，那么其他不能识别的头域将被当
信息头来处理。</pre>
]]></content:encoded>
			<wfw:commentRss>https://huster.top/htmls/163.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>HTTP/1.1之消息</title>
		<link>https://huster.top/htmls/155.html</link>
		<comments>https://huster.top/htmls/155.html#respond</comments>
		<pubDate>Tue, 10 Apr 2012 02:24:09 +0000</pubDate>
		<dc:creator><![CDATA[龙安_任天兵]]></dc:creator>
				<category><![CDATA[HTTP/1.1阅读笔记]]></category>

		<guid isPermaLink="false">http://www.longant.com/?p=155</guid>
		<description><![CDATA[4.1 消息类型 消息的类型分为：请求消息和响应消息。 HTTP-message = Request<a class="moretag" href="https://huster.top/htmls/155.html"> 阅读更多&#8230;</a>]]></description>
				<content:encoded><![CDATA[<p>4.1 消息类型</p>
<p>消息的类型分为：请求消息和响应消息。 HTTP-message = Request | Response ; HTTP/1.1 messages，任何类型的消息都是由开始行，0个或是多个头域，一个空行（CRLF）用来终止头信息，消息实体（也可能没有）。</p>
<p><span id="more-155"></span></p>
<pre>generic-message =      start-line
                          *(message-header CRLF)
                          CRLF
                          [ message-body ]
        start-line      = Request-Line | Status-Line
一个服务器在处理请求的时候，应该能够自动的过滤CRLF这样的空行。
一般一个存在问题的HTTP/1.0的客户端会在POST请求后，添加额外的CRLF，一个HTTP/1.1客户端不应该在请求前和请求后添加不必要的CRLF
4.2消息头
消息头有常用头、请求头、响应头和消息头几种。每一个头域由头名 ：值域 组成，头的名不区分大小写的。</pre>
<pre>message-header = field-name ":" [ field-value ]
       field-name     = token
       field-value    = *( field-content | LWS )
       field-content  = &lt;the OCTETs making up the field-value
                        and consisting of either *TEXT or combinations
                        of token, separators, and quoted-string&gt;
头域的顺序是不强制要求的，但是最好是按照：常用头域、请求|响应头域，实体头域。
4.3 消息主体
通常，消息主体和实体是等价的，除非头域指定了 transfer-coding，对于响应消息，有没有消息实体是由请求方法和响应状态来决定的。HEAD请求不应该包含任何消息主体
哪怕是消息头域。另外，所有1XX，202（无内容），304（没有修改）的状态，都不能包含消息主体。其他任何情况都必须要包含消息主体，哪怕长度为0.
4.4 消息长度
当消息主体出现在消息中时候，一条信息的传输长度就是信息主体的长度，他由以下条件决定：
1.任何不包含消息主体的消息总是被头域得第一个空行CRLF终止。
2.如果Transfer-Encoding头域（见14.41节）出现，并且它的域值是非”“dentity”传输编码值，那么传输长度（transfer-length）被“块”（chunked）传输编码定义，除非消息因为通过
关闭连接而结束。
3.。如果出现Content-Length头域（属于实体头域）（见14.13节），那么它的十进制值（以字节表示）即代表实体主体长度（entity-length）。如果一个消息即存在传输译
码（Transfer-Encoding）头域并且也Content-Length头域，后者会被忽略。
4.如果消息用到媒体类型“multipart/byteranges”，并且传输长度（transfer-length）另外也没有指定，那么这种自我定界的媒体类型定义了传输长度（transfer-length）。
5.。通过服务器关闭连接能确定消息的传输长度。（请求端不能通过关闭连接来指明请求消息体的结束，因为这样可以让服务器没有机会继续给予响应）。
4.5 常用头域
有一些头域即适用于请求消息也适用于响应消息，但是这些头域并不适合传输实体。这些头域只能应用于传输消息


</pre>
]]></content:encoded>
			<wfw:commentRss>https://huster.top/htmls/155.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>HTTP/1.1阅读第2～3章</title>
		<link>https://huster.top/htmls/152.html</link>
		<comments>https://huster.top/htmls/152.html#respond</comments>
		<pubDate>Mon, 09 Apr 2012 03:16:57 +0000</pubDate>
		<dc:creator><![CDATA[龙安_任天兵]]></dc:creator>
				<category><![CDATA[HTTP/1.1阅读笔记]]></category>
		<category><![CDATA[HTTP/1.1]]></category>

		<guid isPermaLink="false">http://www.longant.com/?p=152</guid>
		<description><![CDATA[2 符号习惯和一般语法 2.1 扩充的BNF（扩充的 巴科斯-诺尔范式） 本文档规定的所有机制都用两<a class="moretag" href="https://huster.top/htmls/152.html"> 阅读更多&#8230;</a>]]></description>
				<content:encoded><![CDATA[<p>2 符号习惯和一般语法</p>
<p><span id="more-152"></span></p>
<p>2.1 扩充的BNF（扩充的 巴科斯-诺尔范式）<br />
本文档规定的所有机制都用两种方法描述：散文体（prose）和类似于RFC 822 的扩充Backus-Naur Form（BNF）。要理解本规范，使用者需熟悉符号表示法。扩充BNF结构如下：<br />
名字（name）=定义（definition）<br />
名字（name）就是代表规则的名字，规则名里不能包含“&lt;”和“&gt;”，通过等号把规则名和规则定义（definiation）分离开。空格只有在采用延续行缩进来指定跨度多于一行的规则定义的时候才有意义。某些基本规则（basic rules）使用大写字母包含在规则定义里， 如SP，LWS，HT，CRLF，DIGIT，ALPHA，等等。尖括号可以包含在规则定义里，只要它们的存在有利于区分规则名的使用。</p>
<p>“字面文本”（“literal”）<br />
字面文本（literal text）两边用引号。除非声明，字面文本大小写不敏感（译注：如，HEX =&#8221;A&#8221; | &#8220;B&#8221; | &#8220;C&#8221; | &#8220;D&#8221; | &#8220;E&#8221; | &#8220;F&#8221; | &#8220;a&#8221; | &#8220;b&#8221; | &#8220;c&#8221; | &#8220;d&#8221; | &#8220;e&#8221; | &#8220;f&#8221; | DIGIT 里的A，B,C，D等等都是字面文本（literal text））。</p>
<p>规则1 | 规则2</p>
<p>由竖线（“|”）分开的元素是可选的，例如，“yes | no”表示yes或no都是可接受的。</p>
<p>(规则1 规则2)<br />
围在括号里的多个元素视作一个元素。所以，“(elem (foo | bar) elem)”符合的字符串是“elem foo elem”和“elem bar elem”。 实际上是两个元素，但是用一个都足以表达了。</p>
<p>*规则<br />
前面的字符“*”表示重复。完整的形式是“&lt;n&gt;*&lt;m&gt;元素”，表示元素至少出现&lt;n&gt;次，至多出现&lt;m&gt;次。默认值是0和无穷大，所以&#8221;*（元素）&#8221;允许任何数值，包括零；&#8221;1*元素&#8221;至少出现一次；&#8221;1*2element&#8221;允许出现一次或两次。</p>
<p>[规则]<br />
方括号里是任选元素；“[foo bar]”相当于“*1（foo bar）”。选其中一个，且必须选一个。</p>
<p>N 规则<br />
特殊的重复：“&lt;n&gt;（元素）”与“&lt;n&gt;*&lt;n&gt;（元素）”等价；就是说，（元素）正好出现&lt;n&gt;次。这样2DIGIT是一个两位数字，3ALPHA是一个由三个字符组成的字符串。</p>
<p>#规则<br />
类似于“*”，结构“#”是用来定义一系列元素的。完整的形式是&lt;n&gt;#&lt;m&gt;元素，表示至少&lt;n&gt;个<br />
元素，至多&lt;m&gt;个元素，（*表示重复出现多少次）元素之间被一个或多个逗号（“,”）以及可选的线性空白（LWS）隔<br />
开了。这就使得表示列表这样的形式变得非常容易；像(*LWS element *(*LWS &#8220;,&#8221;*LWS element))<br />
就可以表示为1#element无论在哪里使用这个结构，空元素都是允许的，但是不计入元素出现的次数。换句话说 ，“（element ）, , （element） ”是允许的，但是仅仅视为两个元素。因此，在至少需要一个元素的地方，必须存在至少一个非空元素。默认值是0和无穷大，这样，“#element”允许任意零个或多个元素；“1# element”需要至少一个；“1#2element”允许一个或两个元素。</p>
<p>注释（comment）<br />
用分号引导注释。<br />
隐含的*LWS<br />
本规范所描述的语法是基于字（word-based）的。除非特别注明，线性空白（LWS）可以出现在任何两个相邻字之间（标记（token）或引用字符串（quoted-string）），以及相邻字和间隔符之间，但是这并没有改变对一个域的解释。任何两个标记（token）之间必须有至少一个分割符，否则将会被理解为只是一个标记。</p>
<p>2.2基本规则 （basic rule）</p>
<p>下面的规则贯穿于本规范的全文，此规则描述了基本的解析结构。US-ASCII（美国信息交换标准码）编码字符集是由ANSI X3.4-1986[21]定义的。<br />
OCTET（字节） = &lt;任意八比特的数据序列&gt;<br />
CHAR = &lt;任意ASCII字符（ascii码值从 0到127的字节）&gt;<br />
UPALPHA = &lt;任意大写字母&#8221;A&#8221;&#8230;&#8221;Z&#8221;&gt;<br />
LOALPHA = &lt;任意小写字母&#8221;a&#8221;&#8230;&#8221;z&#8221;&gt;<br />
ALPHA = UPALPHA | LOALPHA<br />
DIGIT = &lt;任意数字0，1，&#8230;9&gt;<br />
CTL = &lt;任意控制字符（ascii码值从0 到 31的字节）及删除键DEL（127&gt;<br />
CR = &lt;US-ASCII CR, 回车（13）&gt;<br />
LF = &lt;US-ASCII LF, 换行符（10）&gt;<br />
SP = &lt;US-ASCII SP, 空格（32）&gt;<br />
HT = &lt;US-ASCII HT, 水平制表 （9）&gt;<br />
&lt;&#8220;&gt; = &lt;US-ASCII双引号（34）&gt;</p>
<p>HTTP/1.1 将 CR LF 的序列定义为任何协议元素的行尾标志，但这个规定对实体主体<br />
（endtity-body）除外（要求比较松的应用见附录19.3）。实体主体（entity-body）的行尾标志<br />
是由其相应的媒体类型定义的，如3.7节所述。<br />
CRLF = CR LF</p>
<p>HTTP/1.1 的消息头域值可以折叠成多行，但紧接着的被折叠行由空格（SP）或水平制表（HT）折叠标记开始。所有的线性空白（LWS）包括被折叠行的折叠标记（空格SP或水平制表键HT），具有同SP一样的语义。接收者在解析域值并且将消息转送到下游（downstream）之前可能会将任何线性空白（LWS）替换成单个SP（空格）。<br />
LWS = [CRLF] 1*(SP | HT)</p>
<p>下面的TEXT规则仅仅适用于头域内容和值的描述，不会被消息解释器解析。TEXT里的字可以包含不仅仅是ISO-8859-1[22]里的字符集，也可以包含RFC 2047里规定的字符集。<br />
TEXT = &lt;除CTLs以外的任意OCTET，但包括LWS&gt;<br />
一个CRLF只有作为HTTP消息头域延续的一部分时才在TEXT定义里使用。<br />
十六进制数字字符用在多个协议元素（protocol element）里。<br />
HEX = &#8220;A&#8221; | &#8220;B&#8221; | &#8220;C&#8221; | &#8220;D&#8221; | &#8220;E&#8221; | &#8220;F&#8221;<br />
| &#8220;a&#8221; | &#8220;b&#8221; | &#8220;c&#8221; | &#8220;d&#8221; | &#8220;e&#8221; | &#8220;f&#8221; | DIGIT</p>
<p>许多HTTP/1.1的消息头域值是由LWS或特殊字符分隔的字构成的。这些特殊字符必须先被包<br />
含在引用字符串（quoted string）里之后才能用于参数值（如3.6节定义）里。<br />
token （标记） = 1*&lt;除CTLs与分割符以外的任意CHAR &gt;<br />
separators（分割符） = &#8220;(&#8221; | &#8220;)&#8221; | &#8220;&lt;&#8221; | &#8220;&gt;&#8221; | &#8220;@&#8221;<br />
| &#8220;,&#8221; | &#8220;;&#8221; | &#8220;:&#8221; | &#8220;\&#8221; | &lt;&#8220;&gt;<br />
| &#8220;/&#8221; | &#8220;[&#8221; | &#8220;]&#8221; | &#8220;?&#8221; | &#8220;=&#8221;<br />
| &#8220;{&#8221; | &#8220;}&#8221; | SP | HT<br />
通过用圆括号括起来，注释（comment）可以包含在一些HTTP头域里。注释只能被包含在域<br />
值定义里有“comment”的域里。在其他域里，圆括号被视作域值的一部分。<br />
comment （注释）= &#8220;(&#8221; *(ctext | quoted-pair | comment )” )&#8221;<br />
ctext = &lt;除&#8221;(&#8221; 和 &#8220;)&#8221;以外的任意TEXT &gt;<br />
如果一个TEXT若被包含在双引号里，则当作一个字。<br />
quoted-string = （ &lt;&#8220;&gt; *（qdtext | quoted-pair ） &lt;&#8220;&gt; ）<br />
qdtext = &lt;any TEXT except &lt;&#8220;&gt;&gt;<br />
斜划线（&#8221;\&#8221;）可以被作为单字符的引用机制，但是必须要在quoted-string和comment构造之<br />
内。<br />
quoted-pair = &#8220;\&#8221; CHAR<br />
3 协议参数<br />
3.1 HTTP版本<br />
HTTP使用一个“&lt;major&gt;.&lt;minor&gt;”数字模式来指明协议的版本号。为了进一步的理解HTTP通信，协议的版本号指示了发送端指明消息的格式和能力，而不仅仅是通过双方通信而获得的通信特性。当消息元素的增加不会影响通信行为或扩展了域值时，协议版本是不需要修改的。当协议会因为添加一些特征而做了修改时，&lt;minor&gt;数字就会递增。这些修改不会影响通常的消息解析算法，但它会给消息添加额外的语意（semantic）并且会暗示发送者具有额外的能力。协议的消息格式发生变化时，&lt;major&gt;数字就会增加。HTTP消息的版本在HTTP-Version域被指明，HTTP-Version域在消息的第一行中。</p>
<p>注意major和minor数字必须被看成两个独立整数，每个整数都可以递增，并且可以增大到大于一位数的整数，如HTTP/2.4比HTTP/2.13低，而HTTP/2.4又比HTTP/12.3低。前导0必须被接收者忽略并且不能被发送者发送。</p>
<p>网关或代理服务器版本不能容忍用户端发送过来的高版本的协议的时候，就会触发一个错误。</p>
<p>3.2 通用资源标识符（URI）</p>
<p>URIs有许多名字已为人所知：WWW地址，通用文档标识符，通用资源标识符[3]，以及后来的统一资源定位器（URL）[4]和统一资源名称（URN）[20]。就HTTP而言，通用资源标识符（URI）只是简单的格式化字符串&#8212;通过名称，位置，或其它特征&#8212;识别一个资源。</p>
<p>根据使用的背景，HTTP里的URIs可以表示成绝对（absoulute）形式或相对形式（相对URI基于根URI[11]）。两种形式的区别是根据这样的事实：绝对URI总是以一个模式（scheme）名作为开头，其后是一个冒号。关于URL 更详尽的语法和含义请参看“统一资源标识符<br />
（URI）:一般语法和语义”，RFC 2396 [42]（代替了RFCs 1738 [4]和RFC 1808 [11]）。本规范采用了RFC 2396 里的” URIreference”， &#8220;absoluteURI&#8221; ， &#8220;relativeURI&#8221; ， &#8220;port&#8221; ， &#8220;host&#8221; ， &#8220;abs_path&#8221; ， &#8220;rel_path&#8221;,和&#8221;authority&#8221;的定义格式。</p>
<p>HTTP协议不对URI的长度作事先的限制，服务器必须能够处理任何他们提供资源的URI，并且应该能够处理无限长度的URIs，这种无效长度的URL可能会在客户端以基于GET方式的请求时产生。如果服务器不能处理太长的URI的时候，服务器应该返回414状态码（此状态码代表Request-URI太长）。</p>
<p>在HTTP协议里，http模式（http scheme）被用于定位网络资源（resourse）的位置。本节定义了http URLs这种特定模式（scheme）的语法和语义。<br />
http_URL = &#8220;http:&#8221; &#8220;//&#8221; host [ &#8220;:&#8221; port ] [ abs_path [ &#8220;?&#8221; query ]]<br />
如果端口为空或未给出，就假定为80。它的语义即：已识别的资源存放于正在监听tcp连接的那个端口的服务器上，并且请求资源的的Request-UR为绝对路径（5.1.2节）。无论什么可能的时候，URL 里使用IP 地址都是应该避免的（参看RFC 1900 [24]）。如果绝对地址（abs_path）没有出现在URL 里，那么应该给出&#8221;/&#8221;。如果代理（proxy）收到一个主机（host）名，但是这个主机名不是全称域名（fully quanlified domain name），则代理应该把它的域名加到主机名上。如果代理（proxy）接收了一个全称域名，代理不能改变主机（host）名称。</p>
<p>3.2.3 URI 比较</p>
<p>当比较两个URI是否匹配时，客户应该对整个URI比较时应该区分大小写，并且一个字节一<br />
个字节的比较。 但下面有些特殊情况：<br />
&#8211; 一个为空或未给定的端口等同于URI-refernece（见RFC 2396）里的默认端口;<br />
&#8211; 主机（host）名的比较必须不区分大小写;<br />
&#8211; 模式（scheme）名的比较必须是不区分大小写的;<br />
&#8211; 一个空绝对路径（abs_path）等同于&#8221;/&#8221;。<br />
除了“保留（reserved）”和“不安全（unsafe）”字符集里的字符（参见RFC 2396[42]） ，其它字符和它们的&#8221;%HEXHEX&#8221;编码的效果一样。<br />
例如,以下三个URI是等同的:<br />
http://abc.com:80/~smith/home.html<br />
http://ABC.com/%7Esmith/home.html<br />
http://ABC.com:/%7esmith/home.html<br />
3.3 日期/时间格式（Date/Time Formats）<br />
3.3.1 完整日期 （Full Date）<br />
HTTP应用曾经一直允许三种不同日期/时间格式：<br />
Sun, 06 Nov 1994 08:49:37 GMT ; RFC 822, updated by RFC 1123<br />
Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036<br />
Sun Nov 6 08:49:37 1994 ; ANSI C&#8217;s asctime（） format<br />
第一种格式是作为Internet 标准提出来的，它是一个国定长度的，由RFC 1123 [8]（RFC822[9]的升级版本）定义的一个子集。第二种格式使用比较普遍，但是基于废弃的RFC 850[12]协议，并且没有年份。如果HTTP/1.1客户端和服务器要解析日期，他们必须能接收所有三种格式（为了兼容HTTP/1.0），但是它们只能用RFC 1123 里定义的日期格式来填充头域（header field）的值里用到HTTP-date的地方。<br />
注:日期值的接收者被鼓励能可靠地接收来自于非HTTP应用程序发送的的日期值，例如有时<br />
可以通过代理（proxy）/网关（gateway）向SMTP或NNTP获取或提交消息。<br />
所有的HTTP日期/时间都必须以格林威治时间（GMT）表示。对HTTP而言，GMT完全等同于UTC（世界协调时间）。前两种日期/时间格式里包含“GMT”，它是时区的三个字面的简写，并且当读到一个asctime格式时必须先被假定是GMT时间。HTTP日期（HTTP-date）区分大小写，不能在此语法中除SP之外包含一个多余的LWS。<br />
HTTP-date = rfc1123-date | rfc850-date | asctime-date<br />
rfc1123-date = wkday &#8220;,&#8221; SP date1 SP time SP &#8220;GMT&#8221;<br />
rfc850-date = weekday &#8220;,&#8221; SP date2 SP time SP &#8220;GMT&#8221;<br />
asctime-date = wkday SP date3 SP time SP 4DIGIT<br />
date1 = 2DIGIT SP month SP 4DIGIT<br />
; day month year （e.g., 02 Jun 1982）<br />
date2 = 2DIGIT &#8220;-&#8221; month &#8220;-&#8221; 2DIGIT<br />
; day-month-year （e.g., 02-Jun-82）<br />
date3 = month SP （ 2DIGIT | （ SP 1DIGIT ））<br />
; month day （e.g., Jun 2）<br />
time = 2DIGIT &#8220;:&#8221; 2DIGIT &#8220;:&#8221; 2DIGIT<br />
; 00:00:00 &#8211; 23:59:59<br />
wkday = &#8220;Mon&#8221; | &#8220;Tue&#8221; | &#8220;Wed&#8221;<br />
| &#8220;Thu&#8221; | &#8220;Fri&#8221; | &#8220;Sat&#8221; | &#8220;Sun&#8221;<br />
weekday = &#8220;Monday&#8221; | &#8220;Tuesday&#8221; | &#8220;Wednesday&#8221;month = &#8220;Jan&#8221; | &#8220;Feb&#8221; | &#8220;Mar&#8221; | &#8220;Apr&#8221;<br />
| &#8220;May&#8221; | &#8220;Jun&#8221; | &#8220;Jul&#8221; | &#8220;Aug&#8221;<br />
| &#8220;Sep&#8221; | &#8220;Oct&#8221; | &#8220;Nov&#8221; | &#8220;Dec&#8221;<br />
注意：HTTP对日期/时间格式的要求仅仅应用在协议流的使用。客户和服务器不必把这种格式应用于用户呈现（user presentation），请求记录日志，等等。.</p>
<p>3.3.2 Delta Seconds （秒间隔）<br />
一些HTTP头域（header field）允许时间值以秒为单位，以十进制整数表示，此值代表消息接收后的时间。<br />
delta-seconds = 1*DIGIT</p>
<p>3.4 字符集 （Character Sets）<br />
HTTP使用术语“字符集”的定义，这和MIME中所描述的是一样.<br />
本文档中的术语“字符集”涉及到一种方法，此方法是用单个或多个表将一个字节序列转换成一个字符序列（译注：从这里来看，这应该是一种映射关系，表保存了映射关系）。注意在反方向上无条件的转换是不成立的，因为并不是所有的字符都能在一个给定的字符集里得到，一个字符集里可能提供多个字节序列表征一个特定的字符。这个定义为的是允许不同种类的字符编码从单一简单表映射（如US-ASCII）到复杂表的转换方法，例如利用ISO-2022技术。然而，相关于MIME字符集名字的定义必须要充分指定从字节到字符的映射。特别是利用外部外围信息来精确确定映射是不允许的.<br />
注：这里使用的术语“字符集”一般的被称作一种“字符编码”。不过既然HTTP和MIME在</p>
<p>同一机构注册，术语统一是很重要的。<br />
HTTP字符集的标记（token）是用不区分大小写的。所有的标记由IANA字符集注册机构[19]定<br />
义。<br />
charset = token<br />
尽管HTTP允许用任意标记（token）作为字符集（charset）值，但这个标记已经在IANA字符集注册机构注册过了，那么这个标记必须代表在该注册机构定义的字符集。对那些非IANA定义的字符集，应用程序应该限制使用。<br />
HTTP协议的实现者应该注意IETF字符集的要求[38][41].</p>
<p>3.4.1 丢失字符集（Missing Charset）<br />
一些HTTP/1.0 应用程序当他们解析Content-Type 头时，当发现没有字符集参数（charsetparameter，译注: Content-Type: text/plain; charset=UTF-8，此时charset=UTF-8就是字符集参数）可用时，这意味着接收者必须猜测实体主体（entity body）的字符集到底是什么。如果<br />
发送者希望避免这种情况，他应该在Content-Type头域里包含一个字符集参数，即使字符集是ISO-8859-1的也应该指明，这样就不会让接收者产生混淆。<br />
不幸的是，一些旧的HTTP/1.0客户端不能处理在Content-Type头域里明确指定的字符集参数。HTTP/1.1接收端必须要认真对待发送者提供的字符集；并且当用户代理（user agent，译注：如浏览器）开始呈现一个文档时，虽然用户代理可以猜测文档的字符集，但如果content-type头域里提供了字符集，并且用户代理也支持这种字符集的显示，不管用户代理是否愿意，它必须要利用这种字符集。参见3.7.1节。</p>
<p>3.5 内容编码（Content Codings）<br />
内容编码（content coding）的值表示一种曾经或能被应用于一个实体的编码转换（encodingtransformation）。内容编码主要用于文档的压缩或其它有效的变换，但这种变换必须不能丢失文档的媒体类型的特性，并且不能丢失文档的信息（译注：就像有损压缩和无损压缩，前者不会丢失信息，后者会丢失信息）。实体经常被编码后保存，然后传送出去，并且在接收端被解码。<br />
content-coding = token</p>
<p>所有内容编码（content-coding）的值是不区分大小写的。HTTP/1.1在接受译码 （Accept-Encoding，14.3 节）和内容译码（Content-Encoding）（14.11 节）头域里使用内容编码（content-coding）的值。尽管该值描述了内容编码，更重要的是它指出了一种解码机制，利用<br />
这种机制对实体的编码进行解码。网络分配数字权威（ （IANA）充当内容编码的值标记（token）注册机构。最初，注册表里包<br />
含下列标记:<br />
gzip（压缩程序）<br />
一种由文件压缩程序&#8221;gzip&#8221;（GNU zip）产生的编码格式（在RFC 1952中描述）。这种编码格式是一种具有32位CRC的Lempel-Ziv编码（LZ77）。<br />
compress（压缩）<br />
一种由UNIX文件压缩程序&#8221;compress&#8221;产生的编码格式。这种编码格式是一种具有可适应性的Lempel-Ziv-Welch编码（LZW）。对于将来的编码，用程序名识表征编码格式是不可取。在这里用到他们是因为他们在历史的作用，虽然这样做并不好。为了同以前的HTTP 实现相兼容，应用程序应该将&#8221;x-gzip&#8221;和&#8221;xcompress&#8221;分别等同于&#8221;gzip&#8221;和&#8221;compress&#8221;。<br />
deflate（缩小）<br />
deflate编码是由RFC 1950 [31]定义的&#8221;zlib&#8221;编码格式与RFC 1951 [29]里描述的&#8221;deflate&#8221;压缩<br />
机制的组合的产物。<br />
identity（一致性）<br />
Identity是缺省编码；指明这种编码表明不进行任何编码转换。这种内容编码仅被用于接受译码（Accept-Encoding）头域里，但不能被用在内容译码（Content-Encoding）头域里。.<br />
新的内容编码的值标记（token）应该被注册；为了实现客户和服务器间的互操作性，实现新值的内容编码算法规范应该能公开利用并且能独立实现，并且与本节中被定义的内容编码目的</p>
<p>3.6 传输编码 （Transfer Codings）</p>
<p>3.6.1 块传输编码（Chunked Transfer Coding）</p>
<p>块编码（chunked encoding）改变消息主体使消息主体（message body）成块发送。每一个块有它自己的大小（size）指示器，在所有的块之后会紧接着一个可选的包含实体头域的尾部（trailer）。这种编码允许发送端能动态生成内容，并能携带能让接收端判断消息是否接收完整<br />
的有用信息。</p>
<p>3.7 媒体类型（Media Type）</p>
<p>为了提供开放的，可扩展的数据类型和类型协商，HTTP在Content-Type（14.17节）实体头域和Accept请求头域里利用了网络媒体[17]类型。<br />
media-type = type &#8220;/&#8221; subtype *（ &#8220;;&#8221; parameter ）<br />
type = token<br />
subtype = token<br />
参数（parameter）以一种 属性/值（attribute/value）形式（如3.6节定义）跟随 类型/子类型（type/subtype）。<br />
类型（type），子类型（subtype），和参数（parameter）里属性名称是大小写不敏感的。参数值有可能是大小写敏感的，也可能不是，这根据参数里属性名称的语意。线性空白（LWS）不能被用于类型（type）和子类型（subtype）之间，也不能用于参数的属性和值之间。参数的出现或不出现对处理媒体类型（media-type）可能会有帮助，这取决于它在媒体类型注册表里的定义。<br />
注意一些旧的HTTP应用程序不能识别媒体类型的参数（parameter）。当向一个旧HTTP应用程序发送数据时，发送端只有在被type/subtype定义里需要时才使用类型参数（parameter）。</p>
<p>媒体类型（media-type）值需要被注册到网络数字分配权威（IANA[19]）里。媒体类型的注册程序在RFC 1590[17]中大概描述。使用未经注册的媒体类型是不被鼓励的。</p>
<p>3.7.1 规范化和文本缺省 （Canonicalization and Text Defaults）</p>
<p>3.7.2 多部分类型（Multipart type）</p>
<p>3.8 产品标记 （product Tokens）</p>
<p>3.9 质量值（Quality Values）</p>
<p>3.10 语言标签 （Language Tags）</p>
<p>3.11 实体标签 （Entity Tags）</p>
<p>3.12 范围单位（Range Units）</p>
<p>省略的都是比较不常用的一些约定</p>
]]></content:encoded>
			<wfw:commentRss>https://huster.top/htmls/152.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>HTTP/1.1协议阅读-第一章</title>
		<link>https://huster.top/htmls/131.html</link>
		<comments>https://huster.top/htmls/131.html#respond</comments>
		<pubDate>Thu, 05 Apr 2012 16:39:58 +0000</pubDate>
		<dc:creator><![CDATA[龙安_任天兵]]></dc:creator>
				<category><![CDATA[HTTP/1.1阅读笔记]]></category>
		<category><![CDATA[HTTP/1.1]]></category>

		<guid isPermaLink="false">http://www.longant.com/?p=131</guid>
		<description><![CDATA[我将逐渐完成http/1.1协议的阅读，在此期间，为了加深记忆，会写成一个系列的文章，文中所述，以个<a class="moretag" href="https://huster.top/htmls/131.html"> 阅读更多&#8230;</a>]]></description>
				<content:encoded><![CDATA[<p>我将逐渐完成http/1.1协议的阅读，在此期间，为了加深记忆，会写成一个系列的文章，文中所述，以个人理解为主，以英文为准，尽量靠近原文档，原因是，下载了一个中文版的，读起来发现很别扭，感觉像是从Google翻译，直接翻译过来的，不知所云。</p>
<p>先强制性的翻译几章，熟悉之后，希望能够加快阅读速度，今天先进第一章。</p>
<p><span id="more-131"></span></p>
<p>part of <a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html" rev="Section">Hypertext Transfer Protocol &#8212; HTTP/1.1</a><br />
RFC 2616 Fielding, et al.</p>
<ol>
<li>介绍</li>
</ol>
<p>1.1 文档的目的</p>
<p>HTTP，超文本传输协议，是为分布式的，联合的（合作式的），超媒体信息系统设计的。最开始是在1990年被WWW所用。他最开始是HTTP/0.9，传输的是未经处理的信息。HTTP/1.0将原始数据，改为传输mime格式的数据。这种格式的数据，包含了在请求/响应语法中的原始数据和修改信息。但是1.0的版本，在代理服务器和缓存方面却是一片空白。再加上，为了两个通信的应用程序能够明确各自的能力，自称http/1.0的协议，迫切的需要改进升级</p>
<p>为了更严格的实现其这些特征，这份协议包含了比1.0更严格的需求。</p>
<p>较之于简单的检索，实际应用中，需要更加强大的搜索，端到端的更新以及注释。http/1.1拥有一个能够知名请求目的的头信息。他需要由url，uri个urn指出的请求方法和信息的参考。（好别扭，实际上是说，他需要由URL、URN和URI指明请求的方法、资源等信息）。MIME格式的数据，本身是用于邮件的。HTTP/1.1协议还用于浏览器到代理，或者到各种互联网系统，包含支持SMTP <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec17.html#bib16" rel="bibref">[16]</a>, NNTP <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec17.html#bib13" rel="bibref">[13]</a>, FTP <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec17.html#bib18" rel="bibref">[18]</a>,等</p>
<p>1.2 阅读须知</p>
<p>关键字 &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in RFC 2119 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec17.html#bib34" rel="bibref">[34]</a>.</p>
<p>如果must或者required未被满足，在实现的时候当然是不允许的，就是说，规定了必须的，在实现的时候，就必须满足。满足了必须，没有满足should的叫做有条件服从，而两者都满足的话，叫做无条件服从。</p>
<p>1.3 术语</p>
<p>连接： 两个程序间，一个稳定的环路</p>
<p>消息：在程序间传输的，基本的HTTP单元。</p>
<p>请求：第五章定义的请求信息</p>
<p>响应：第六章定义的响应信息</p>
<p>资源：由URI定义的在3.2章定义的信息</p>
<p>实体：真正传输的信息，包含了头信息和具体的实体信息</p>
<p>陈述：为内容协商准备的包含响应信息的实体（12章）</p>
<p>内容协商：为了达到最适的传输方式的一个机制</p>
<p>变体：资源可能有一种或多种表现形式，每一种表现形式叫做“变种”(??)。</p>
<p>用户代理： 浏览器、爬虫等。</p>
<p>服务器：接受用户请求，做出相应的服务器。</p>
<p>源服务器：存储着资源的服务器。</p>
<p>代理服务器：扮演者服务器和用户代理的角色，接受用户的请求，转发给服务器，再将服务器返回的内容，转发给用户。</p>
<p>网关：为多个服务器服务的一种服务器。与代理服务器不同的是，他穿着源服务器的外衣，欺骗者请求的服务器，让他们无法察觉。</p>
<p>隧道： vpn的意思。</p>
<p>cache：缓存</p>
<p>cacheable：当一个缓存能够存储一个请求的copy的时候，我们就说这个响应是cacheable的。</p>
<p>一手的：直接从源服务器过来的响应就叫一手的，但是又可能是通过了一个或是多个代理的。</p>
<p>明确的终止时间：当源服务器告之不再从缓存返回数据的时刻，就是明确的终止时间。</p>
<p>启发式的终止时间：在明确终止时间不可用时，被缓存安排的一个终止时间</p>
<p>周期：一个周期就是从发出请求到成功接收到请求的一个时间。</p>
<p>新鲜的生命时间：还在终止时间内进行响应的时候，我们说这个服务器还在新鲜的生命时间内。</p>
<p>新鲜的：还没有超过终止时间时候，发出的响应，可以称为是新鲜的。</p>
<p>腐烂的：对比新鲜的，当终止时间已经超过的时候，发出的响应的内容是腐烂的。</p>
<p>语义透明：当它的使用除了提高了性能既没有影响客户机，也没有影响源服务器的时候，我们就说这个高速缓存工作在语义透明的模式。当高速缓存工作在语义透明模式的时候，客户收到的应答和从源服务器收到的应答是相同的。</p>
<p>验证：一种验证机制（例如使用标签实体或是最后修改时间），用来验证缓存是不是真正的是一个实体的拷贝。</p>
<p>上/下游：上下游描述了信息的流动。</p>
<p>向内/向外：向内和向外是描述了信息的请求和应答路径。向内，就是移向源服务器，向外就是移向代理服务器。</p>
<p>HTTP协议是一种请求/应答协议。 与主机建立连接后，客户以请求方法，URI和协议版本的形式向服务器发送请求，继以类MIME信息，其中包括请求修改，客户信息和可能的正文内容。</p>
<p>服务器用包括消息协议版本和成功或错误代码的状态进行应答，继以包括服务器信息，实体维护信息和可能的实体内容的类MIME消息。HTTP和MIME之间的关系如附录19.4节所阐述。</p>
<p>大部分的HTTP通信由用户代理引发，由应用到一些原服务器上资源的请求构成。最简单的情形，可以经用户代理（UA）和原服务器（O）之间的单一连接（v）完成。请求链&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&gt;用户代理(UA)&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-单一连接（v)&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-原服务器（O） &lt;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;应答链</p>
<p>当一个或一个以上的中介在请求/应答链中出现的时候，会出现更复杂的情形。常见的中介形式有三种：代理，网关和隧道。代理是一种转送工具，它接收绝对形式的URI请求，重写全部或部分消息，然后把重新格式化后的请求发送到URI确定的服务器上。网关是一种接收工具，它充当其他服务器的上层，必要时将请求翻译为下层服务器的协议。隧道不改变消息而充当两个连接之间的中继点；它用于通信需要穿过中介（如防火墙），甚至中介不能理解信息内容的时候。<br />
请求链&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;&gt;UA&#8212;&#8211;v&#8212;&#8211;A&#8212;&#8211;v&#8212;&#8211;B&#8212;&#8211;v&#8212;&#8211;C&#8212;&#8211;v&#8212;&#8211;O &lt;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-应答链</p>
<p>上图显示了用户代理和原服务器之间的三个中介（A，B和C)。游历整条链的请求或应答消息需通过四个独立的连接。这个特性很重要，因为某些HTTP通信选项只能应用于到最近的非隧道邻居，链的终点的连接，或者沿着链的所有连接。图表尽管是线性的，每部分可能都在忙于多路同时通信。例如，B可以接收来自不同于A的许多客户的请求，并且／或者转送到不同于C的服务器，与此同时，它还在处理A的请求。</p>
<p>任何非隧道的通信成员都可以使用内部的高速缓存来处理请求。高速缓存的作用是如果沿着链的一个成员对请求采用了高速缓冲的应答，请求/应答链就会大大缩短。以下图解作为结果产生的链，假定B拥有来自O（通过C）的一个从前应答的备份，请求尚未被UA或A缓存。<br />
请求链&#8212;&#8212;&#8212;-&gt;UA&#8212;&#8211;v&#8212;&#8212;&#8212;-A&#8212;&#8211;v&#8212;&#8211;B&#8212;&#8211;C&#8212;-O &lt;&#8212;&#8212;&#8212;应答链</p>
<p>并不是所有的应答都能有效地缓存，一些请求可能含有修改量，对缓存动作有特殊的要求。缓存动作和缓存应答的HTTP要求将在第13节定义。</p>
<p>实际上，目前万维网上有多种结构和配置的高速缓存和代理被实验或使用。这些系统包括节省越洋带宽的全国代理层，广播或多点通信缓存接口， 通过CD-ROM分配子缓存数据的机构，等等。HTTP系统应用在宽频带连接的企业局域网中，通过PDAs的低耗无线连接和断续连接的访问。HTTP1.1的目标是支持各种各样的应用配置，引进协议结构满足那些需要较高可靠性，可以排除故障或至少指示故障的网络应用的要求。</p>
<p>HTTP通信在通常发生在TCP/ＩＰ连接上。默认端口是TCP 80,不过其它端口也可以使用。在互联网或其他网络上，这并不妨碍HTTP应用在其他协议的顶端。http仅仅期望可靠的传输；任何提供这种保证的协议都可以使用；协议传输数据单元的HTTP/1.1请求和应答结构的映象已经超出了本说明书的范围。</p>
<p>在http/1.0中，大部分的实现为每个请求/应答交换使用了新连接。而http/1.1中，一个连接可以用于一个或更多请求/应答交换，虽然连接可能会因为各种原因中断（见第8.1节）。</p>
]]></content:encoded>
			<wfw:commentRss>https://huster.top/htmls/131.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
	</channel>
</rss>
