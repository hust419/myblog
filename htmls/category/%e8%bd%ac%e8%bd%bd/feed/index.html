<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>转载 &#8211; 三两带走</title>
	<atom:link href="http://rentb.vicp.net/htmls/category/%e8%bd%ac%e8%bd%bd/feed" rel="self" type="application/rss+xml" />
	<link>http://huster.top/</link>
	<description>(任天兵)龙安的博客</description>
	<lastBuildDate>Mon, 09 May 2022 13:11:26 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.18</generator>

<image>
	<url>https://huster.top/wp-content/uploads/2018/09/cropped-fish_112.18181818182px_1208536_easyicon.net_-32x32.png</url>
	<title>转载 &#8211; 三两带走</title>
	<link>http://huster.top/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>写给计算机专业毕业生的22条宝贵建议</title>
		<link>https://huster.top/htmls/610.html</link>
		<comments>https://huster.top/htmls/610.html#respond</comments>
		<pubDate>Fri, 26 Oct 2018 06:59:35 +0000</pubDate>
		<dc:creator><![CDATA[龙安_任天兵]]></dc:creator>
				<category><![CDATA[转载]]></category>

		<guid isPermaLink="false">http://huster.top/?p=610</guid>
		<description><![CDATA[自从毕业后，人们一直问我:“现在做什么?”我的回答是毫不含糊的:“我不知道。”“我曾经以为，当我完成硕士学位的 &#8230; <a href="https://huster.top/htmls/610.html" class="more-link">继续阅读<span class="screen-reader-text">“写给计算机专业毕业生的22条宝贵建议”</span></a>]]></description>
				<content:encoded><![CDATA[<p>自从毕业后，人们一直问我:“现在做什么?”我的回答是毫不含糊的:“我不知道。”“我曾经以为，当我完成硕士学位的时候，我就知道该怎么做了。”我以为我会成为一个“大师”。</p>
<p>可是，我错了。学校并没有让我为毕业后的世界做好准备。学校的学术环境能够提供持续的反馈——你稍微偏离了轨道，有人肯定会告诉你，甚至引导你到正确的轨道上。在现实生活中，我害怕自己会做出一系列错误的决定，而当有人指正你的时候已经为时已晚。一个错误的工作选择可能会让我浪费几年的时间，甚至错过许多更好的发展机会。</p>
<p><span id="more-610"></span></p>
<p>当我在网上搜索应届毕业生的就业建议时，我发现大多数文章都是关于如何找工作的。我不想让自己看起来像个势利小人，但实际上，对于很多刚毕业的大学生来说，他们的问题不是“**我能得到什么样的工作**”，而是“**我应该得到什么工作**”。“选择的多样性并没有让决策变得更容易。如果说有什么不同的话，那就是它让像我这样有严重社交恐惧症的人陷入了恐慌。我反复思考了一系列问题：“我应该攻读博士学位吗?”，“我应该在大公司还是初创公司工作?”，“我应该自己创业吗?”，“我应该做工程还是更偏向市场一些?”，“我应该离开科技行业，去追求我的写作兴趣吗?”</p>
<p>在过去的一年里，我向很多人询问了这些问题，无论是在工业界还是学术界，我很幸运，他们中的一些人能够坐下来和我分享他们的见解。因为他们的建议对我有很大的帮助，所以我认为这些可能对其他人也有用，因为他们有一天很可能会经历我做的事情。这篇文章试图用语言表达我经历过的深刻的思考过程和我得到的建议。如果你只是想得到建议而对故事过程不感兴趣的话，可以直接去看最后一部分。</p>
<p>该不该读博士<br />
我的家住在越南的一个小村庄，所以对美国学术界的认知很模糊。我不知道什么是博士学位，人们在博士申请中做些什么，或者如果我想申请的话我应该如何准备。直到去年年初我开始和博士生们一起玩的时候，我才意识到：“哇，这些人真的很聪明。他们研究有趣的问题。我想成为他们那样的人。</p>
<p>我很快意识到，每个人对“考不考博士”这个话题似乎都有自己的看法。我还发现，与我交谈过的教授（也就是那些已经获得博士学位的教授）100%都告诉我应该攻读博士学位，而已经就业的人100%的都告诉我不应该读博了。</p>
<p>支持攻读PhD的观点包括：</p>
<p>你会有时间让自己沉浸在研究中。<br />
如果你想成为一名教授，你就得去读博士。<br />
许多顶尖的研究实验室，比如DeepMind只招聘博士生。<br />
你会得到很好的薪水，人工智能实习生的薪水都很不错。<br />
支持不读博士学位的观点包括:</p>
<p>应该有更多的人加入到工业中来，把研究带到生产中去。<br />
当你完成你的博士学位，你所学与所用的相关性可能不大。<br />
很多情况下，许多教授在行业内都有兼职，所以你仍然可以和他们一起工作。<br />
在接下来的五年里，你不会为钱发愁。<br />
我决定攻读博士学位。由于我已经来不及准备我的博士应用程序了，我的教授建议我明年申请，在这一年的时间里完善我的应用程序，所以我安排了一些研究实习。</p>
<p>我提前了一个季度毕业，接下来的三个月我都在旅行。我并没有刻意寻找我自己，但我偶然发现了它。在这段时间里，我每天都写些有趣的东西，但没有读一篇论文。我意识到**我想读博不是因为我想做人工智能研究，而是因为我想成为做人工智能研究的人**。当我和我的博士朋友们见面，看到他们在醒着的每一刻都在谈论、思考人工智能时，我的这种想法更加强烈了——我没有参与到他们的热情中。我想要不同的东西。有何不同?我还在想办法弄清楚。</p>
<p>做一个违心的人或者追随自己的梦想<br />
斯坦福大学提供CS +英语专业。我们曾经开玩笑说，这个专业是为那些既喜欢写作又想找工作的人开设的。一个朋友却说我就是那种人。</p>
<p>我学计算机专业不是为了找份工作。我从第一节入门课就迷上了它，因为这门课很有趣。我热爱工程，但三个月的休假重新点燃了我的信念：写作是我一生中最大的爱好。由于我已经花了将近4年的时间来攻读CS的学位，我渴望在写作上投入一些时间。我也害怕成为硅谷的另一名软件工程师。</p>
<p>事实证明，如果你是一名外国学生的话，在美国追求自己的理想有时就不太现实了。要留在美国，我必须找到一份与我的专业相关的工作。当然，我可以去另一个国家生活。在南美洲的海滩上生活和写作的想法是相当富有诗意的。但人工智能是一个瞬息万变的领域，我片刻思考后就已经有点迷失了方向——如果我在一年后不能回到这个领域了呢?此外，来回折腾以及搬家移民也将是一场噩梦。</p>
<p>当我带着这样的困惑来到我的教授面前时，他很困惑：**“为什么你一定要在工作和写作之间做出选择?”为什么不两个都要呢?**“有很多人在他们的技术领域都有成就，但也有多产的作家。他对我的能力的坚定自信激发了我的自信：“你说得对。我两样都能做。“我可以全职从事科技工作，晚上或者周末则是写作。我过去在大学里花了大量的时间做作业和教学，所以我相信我可以每周抽出20多小时用来写作。</p>
<p>我应该自己创业吗?<br />
从斯坦福大学毕业，住在硅谷，我无法摆脱创业的刻板印象。有人说我是“创业型”。“有些人甚至邀请我成为他们的联合创始人。</p>
<p>我不止一次受到诱惑。从头构建产品的想法很吸引人。毫无疑问我会学到很多，不仅仅包括我试图解决的问题也包括如何激励人们和我一起工作，如何筹集资金，如何管理一个组织，如何销售我的产品......我有很多朋友做自己的事业，他们的生活中有很多事要做，但从来没有无聊。此外，他们成为亿万富翁的机会比我大得多。</p>
<p>仅仅是阅读那些关于二十多岁年轻人动不动就获得数百万美元融资的新闻就让人心猿意马。就连Yo应用也筹集了150万美元！有人曾把这作为我应该创业的原因之一。但我也见过很多朋友，他们都知道创业的生活充满了压力、残酷，而且受到很多外部因素的制约。我朋友的创业公司中有相当一部分已经失败了，尽管他们非常聪明，有很好的想法，并且得到了著名投资者的支持。每当我感觉自己像个废物时，我就会打电话给我的创业朋友，看看他们的挣扎，并为自己不是他们而感到高兴。</p>
<p>我可能是这里的少数人，但我认为仅仅为了创办一家公司而创办一家公司是没有理由的，是浪费每个人的时间。除非我做到了下面这至少三件事：</p>
<p>这是一个我想用毕生精力去解决的问题。<br />
相信我能解决它。<br />
我可以和一个联合创始人一起工作很长一段时间，而不会感觉对彼此产生厌烦。<br />
现在，这些问题我都没遇到，所以我就呆在这里。我还认为，为别人工作几年，会让我在财务和技能方面都做好为自己工作的准备。</p>
<p>进入大公司还是创业公司<br />
基于以上因素，我开始在英伟达实习。我取消了其他实习计划，开始寻找全职工作。这时，我的下一个大问题出现了：“我应该为一家大公司工作还是为一家初创公司工作?”</p>
<p>我在大学期间曾分别在一家大公司和一家初创公司实习过。我的印象与人们通常所说的大公司稳定、初创公司高强度（高风险）非常一致。在我那些选择不攻读博士学位的朋友中，约有40%的人去了大公司，40%的人在创业公司工作，其余的人自己开了公司。他们都给了我有力的论据。当然，每个公司的优缺点各不相同，下面简单列了一些：</p>
<p>当我与人分享这些思考时，许多人告诉我做让我快乐的事。虽然我很欣赏这种态度，但这个建议经常让我更加困惑。“快乐”到底是什么意思？我该怎么测量呢？“幸福”也是相对的。给自己足够的时间去适应，我们就能教会自己对任何事情都感到快乐。</p>
<p>有两条建议我觉得很有帮助。第一个问题：“**哪一个能给你一个千载难逢的机会？**”“你认为你正在考虑的创业公司正在做一些真正重要的事情，这是你一生中唯一一次为之做出贡献的机会吗？”或者你认为为科技巨头工作是你一生中唯一的机会?</p>
<p>第二个问题是：“**你想得到什么？**”一个最容易得到的东西就是金钱。我的一些朋友面试了多家公司，最终去了出价最高的公司。一些人为了新体验，选择一份能让他们旅行和结识很多人的工作。一些人为了提高自己的声誉，去了他们所在领域最知名的公司。</p>
<p>在我人生的这个阶段，我追求个人成长。我想要一份能给我最大自由成长的工作。这意味着这份工作应该能让我与优秀的同事、导师一起工作，并尽可能地挑战自己。</p>
<p>英伟达<br />
最后，我选择留在英伟达，原因如下。</p>
<p>1. 文化<br />
我和许多公司聊过，英伟达作为一家感觉像是初创企业的大公司，脱颖而出。英伟达的文化信条之一是SOL——光速——你必须快速行动，比一般的大型组织快得多。有一天下午，我和我的经理谈了想全职留在公司工作的事情，第二天我就得到了工作机会。</p>
<p>在Glassdoor上，一些人说，像创业一样的文化意味着更高的工作量。有时你会发现，英伟达缺乏组织架构，这很让人困惑。但我绝对喜欢这种形态。由于公司发展迅速，有很多事情要做。员工可以去有挑战的地方，根据自己的能力选择挑战性。</p>
<p>扁平的等级制度。你可以接触到每一个人，他们会听你的。即使在实习期间，我也有机会与两位高级经理共事。黄仁勋曾经给我一杯啤酒。我的经历绝不是独一无二的。</p>
<p>此外，黄仁勋是有史以来最酷的CEO。他的风格是热情的（皮夹克哟）和恰到好处的幽默感。他邀请所有的实习生来他家参加夏季晚会，每个人都很喜欢他。**一个很酷的CEO才能建立一个很酷的公司**。</p>
<p>2. 工作<br />
英伟达以硬件闻名，但他们也有强大的软件工程团队。我的经理让我选择我想做的工作。工作范围从研究到大规模生产，有很多项目供我选择。**我的工作并不局限于一小段代码，我可以成为一个项目的责任人。我也可以和其他团队的人一起工作**。有一次，我对某人的工作印象深刻，他在另一个团队。我联系了他，并一起做了一个项目。</p>
<p>我发现我喜欢我在英伟达的工作，甚至在一个星期六，我突然有一种冲动，想去办公室完成一些实验。**我在工作中从未感到无聊**。总有事情要做，总有人要跟你说话。我学到了很多。</p>
<p>3. 影响<br />
英伟达的**管理人员与员工分享公司的战略**，这是不可思议的。即使作为一个低级别的工程师，我觉得我知道公司的发展方向。</p>
<p>英伟达是雄心勃勃的。他们研究了许多具有巨大潜力的项目。我可以改变我正在做的项目。经理们关注你的工作，以确保员工得到应有的回馈。我曾经自愿为公司做一些事情，我的工作得到了一位副总裁和两位高级董事的详细反馈。其他大公司不太可能发生这种情况。</p>
<p>4. 斗争<br />
硬件竞争现在非常激烈。每个科技巨头似乎都想分一杯羹。在英伟达(NVIDIA)工作让我有机会坐在前排观看这场战斗。</p>
<p>当我问我的经理为什么从苹果公司跳槽到这里时，他说这是因为“斗争”。由于某种原因，我还没有内化，成为英伟达的一员似乎是一种英雄。我想尽我最大的努力帮助英伟达赢得这场比赛。</p>
<p>有些人可能会问：薪水怎么样？你的思维过程中真的没有考虑过金钱么？如果有人在硕士课程刚毕业的时候提到他们的奖金上有一张6位数的签名，说我没被诱惑，那是在撒谎。和许多同龄人一样，**我的目标是有一天拥有足够的钱，不再为钱而工作**。</p>
<p>但就目前而言，在科技行业工作，我知道无论我选择什么工作，都可能给我足够的薪水。我相信，如果我选择个人成长，总有一天，我将拥有一套足够令人向往的技能，能够赚到比我花的多的多的钱。青春太珍贵，不能用钱衡量。</p>
<p>供参考建议如下：</p>
<p>知道你想要什么：金钱、新体验、声望、个人成长，还是别的什么?<br />
如果你不知道你想做什么，关注你在空闲时间做什么。只有当没人看的时候你才会表现出真正的兴趣。<br />
至少对人工智能来说，工业和学术界之间的界线越来越模糊。不要担心是否有博士学位。你可以开始读博，然后退学，或者在工业界工作几年后再申请博士学位。<br />
在GitHub上发布你的代码，投入时间去构建一些像样的GitHub repos。我的GitHub就给我增加了不少印象分。<br />
不要太在意你的GPA。如果你认为它很低（例如&lt; 3.3），那就不要写在简历上。只要你有良好的技术背景（比如过去的实习经验+项目+ GitHub），没人会在意你的GPA。<br />
在大学期间，在大公司和创业公司实习，以了解你想加入什么样的组织。<br />
早期你可以应聘“实习转全职”的职位。实习面试比全职面试容易3倍。<br />
尽早开始找工作，最好是在大四开始。我的大多数朋友都提前2-3个季度拿到了offer。早期的工作机会能让你在面试中保持平和的心态，并在以后的面试中占据优势。<br />
不要因为没有收到一些公司的回复就放弃。我认识一些人，他们在找到工作之前会把简历投给数百家公司。<br />
技术面试是一种痛苦。至少提前一个月准备。<br />
在面试过程中，询问你将在这个职位上做什么工作，你要向哪个经理汇报工作，以及你将得到什么样的指导。<br />
不要回避谈判。即使你不是为了钱而工作，你也完全有权利得到你应得的报酬。<br />
根据我的经验，公司总是会根据简历竞争力提供报价，即使他们说他们不会。我曾见过两位有类似经历的朋友加入同一家公司担任同一职位，但其中一位因为有竞争性的简历每年多赚5万美元。<br />
向你钦佩的人请教经验和职业建议。<br />
看看Glassdoor上的评论，你就会知道你要做什么了。<br />
在大学结束后开始你的第一份全职工作之前先休息一段时间，因为在很长一段时间内你不太可能再去度假了。<br />
如果你工作的唯一原因是薪水，那就辞职吧。<br />
如果你发现自己没有在工作中学到东西，那就离开吧。<br />
不要用不正当的竞争手段。<br />
不要拿自己和别人比较。不管你有多优秀，总会有人在某方面比你强。你需要将你的今天和昨天进行比较。<br />
做一个友善的人。<br />
善待自己。你不需要在xx大学毕业，在xx年获得博士学位，或者在xx年成为百万富翁。要去探索这个世界。去了解你自己。享受这个过程。<br />
查看英文原文：https://huyenchip.com/2018/10/08/career-advice-recent-cs-graduates.html</p>
]]></content:encoded>
			<wfw:commentRss>https://huster.top/htmls/610.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>并发编程模型(转载)</title>
		<link>https://huster.top/htmls/557.html</link>
		<comments>https://huster.top/htmls/557.html#comments</comments>
		<pubDate>Tue, 19 Jun 2018 11:22:46 +0000</pubDate>
		<dc:creator><![CDATA[龙安_任天兵]]></dc:creator>
				<category><![CDATA[Java学习]]></category>
		<category><![CDATA[转载]]></category>

		<guid isPermaLink="false">http://huster.top/?p=557</guid>
		<description><![CDATA[这篇文章写的可是真好，把以前模模糊糊的概念弄的很清晰 并发编程模型 原文链接 作者: Jakob Jenkov &#8230; <a href="https://huster.top/htmls/557.html" class="more-link">继续阅读<span class="screen-reader-text">“并发编程模型(转载)”</span></a>]]></description>
				<content:encoded><![CDATA[<p>这篇文章写的可是真好，把以前模模糊糊的概念弄的很清晰</p>
<p><span id="more-557"></span></p>
<h3 class="title">并发编程模型</h3>
<div class="post_content">
<p><a title="concurrency-models" href="http://tutorials.jenkov.com/java-concurrency/concurrency-models.html" target="_blank" rel="noopener">原文链接</a> 作者: Jakob Jenkov 译者: 林威建 [weakielin@gmail.com]</p>
<p>并发系统可以采用多种并发编程模型来实现。并发模型指定了系统中的线程如何通过协作来完成分配给它们的作业。不同的并发模型采用不同的方式拆分作业，同时线程间的协作和交互方式也不相同。这篇并发模型教程将会较深入地介绍目前（2015年，本文撰写时间）比较流行的几种并发模型。<br />
<span id="more-19235"></span></p>
<h1>并发模型与分布式系统之间的相似性</h1>
<p>本文所描述的并发模型类似于分布式系统中使用的很多体系结构。在并发系统中线程之间可以相互通信。在分布式系统中进程之间也可以相互通信（进程有可能在不同的机器中）。线程和进程之间具有很多相似的特性。这也就是为什么很多并发模型通常类似于各种分布式系统架构。</p>
<p>当然，分布式系统在处理网络失效、远程主机或进程宕掉等方面也面临着额外的挑战。但是运行在巨型服务器上的并发系统也可能遇到类似的问题，比如一块CPU失效、一块网卡失效或一个磁盘损坏等情况。虽然出现失效的概率可能很低，但是在理论上仍然有可能发生。</p>
<p>由于并发模型类似于分布式系统架构，因此它们通常可以互相借鉴思想。例如，为工作者们（线程）分配作业的模型一般与分布式系统中的<a title="负载均衡" href="http://tutorials.jenkov.com/software-architecture/load-balancing.html" target="_blank" rel="noopener">负载均衡系统</a>比较相似。同样，它们在日志记录、失效转移、幂等性等错误处理技术上也具有相似性。<br />
【注：幂等性，一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同】</p>
<h1>并行工作者</h1>
<p>第一种并发模型就是我所说的并行工作者模型。传入的作业会被分配到不同的工作者上。下图展示了并行工作者模型：<br />
<img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-1.png" alt="并行工作者模型" /><br />
在并行工作者模型中，委派者（Delegator）将传入的作业分配给不同的工作者。每个工作者完成整个任务。工作者们并行运作在不同的线程上，甚至可能在不同的CPU上。</p>
<p>如果在某个汽车厂里实现了并行工作者模型，每台车都会由一个工人来生产。工人们将拿到汽车的生产规格，并且从头到尾负责所有工作。</p>
<p>在Java应用系统中，并行工作者模型是最常见的并发模型（即使正在转变）。<a title="java-concurrent-utils" href="http://tutorials.jenkov.com/java-util-concurrent/index.html" target="_blank" rel="noopener">java.util.concurrent包</a>中的许多并发实用工具都是设计用于这个模型的。你也可以在Java企业级（J2EE）应用服务器的设计中看到这个模型的踪迹。</p>
<h2>并行工作者模型的优点</h2>
<p>并行工作者模式的优点是，它很容易理解。你只需添加更多的工作者来提高系统的并行度。</p>
<p>例如，如果你正在做一个网络爬虫，可以试试使用不同数量的工作者抓取到一定数量的页面，然后看看多少数量的工作者消耗的时间最短（意味着性能最高）。由于网络爬虫是一个IO密集型工作，最终结果很有可能是你电脑中的每个CPU或核心分配了几个线程。每个CPU若只分配一个线程可能有点少，因为在等待数据下载的过程中CPU将会空闲大量时间。</p>
<h1>并行工作者模型的缺点</h1>
<p>并行工作者模型虽然看起来简单，却隐藏着一些缺点。接下来的章节中我会分析一些最明显的弱点。</p>
<h3>共享状态可能会很复杂</h3>
<p>在实际应用中，并行工作者模型可能比前面所描述的情况要复杂得多。共享的工作者经常需要访问一些共享数据，无论是内存中的或者共享的数据库中的。下图展示了并行工作者模型是如何变得复杂的：<br />
<img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-2.png" alt="并行工作者模型的复杂情况" /><br />
有些共享状态是在像作业队列这样的通信机制下。但也有一些共享状态是业务数据，数据缓存，数据库连接池等。</p>
<p>一旦共享状态潜入到并行工作者模型中，将会使情况变得复杂起来。线程需要以某种方式存取共享数据，以确保某个线程的修改能够对其他线程可见（数据修改需要同步到主存中，不仅仅将数据保存在执行这个线程的CPU的缓存中）。线程需要避免<a title="竞争状态" href="http://tutorials.jenkov.com/java-concurrency/race-conditions-and-critical-sections.html" target="_blank" rel="noopener">竟态</a>，<a title="死锁" href="http://tutorials.jenkov.com/java-concurrency/deadlock.html" target="_blank" rel="noopener">死锁</a>以及很多其他共享状态的并发性问题。</p>
<p>此外，在等待访问共享数据结构时，线程之间的互相等待将会丢失部分并行性。许多并发数据结构是阻塞的，意味着在任何一个时间只有一个或者很少的线程能够访问。这样会导致在这些共享数据结构上出现竞争状态。在执行需要访问共享数据结构部分的代码时，高竞争基本上会导致执行时出现一定程度的串行化。</p>
<p>现在的<a title="无阻塞算法" href="http://tutorials.jenkov.com/java-concurrency/non-blocking-algorithms.html" target="_blank" rel="noopener">非阻塞并发算法</a>也许可以降低竞争并提升性能，但是非阻塞算法的实现比较困难。</p>
<p>可持久化的数据结构是另一种选择。在修改的时候，可持久化的数据结构总是保护它的前一个版本不受影响。因此，如果多个线程指向同一个可持久化的数据结构，并且其中一个线程进行了修改，进行修改的线程会获得一个指向新结构的引用。所有其他线程保持对旧结构的引用，旧结构没有被修改并且因此保证一致性。Scala编程包含几个持久化数据结构。<br />
【注：这里的可持久化数据结构不是指持久化存储，而是一种数据结构，比如Java中的String类，以及CopyOnWriteArrayList类，具体可<a title="可持久化的数据结构" href="http://www.cnblogs.com/tedzhao/archive/2008/11/12/1332112.html" target="_blank" rel="noopener">参考</a>】</p>
<p>虽然可持久化的数据结构在解决共享数据结构的并发修改时显得很优雅，但是可持久化的数据结构的表现往往不尽人意。</p>
<p>比如说，一个可持久化的链表需要在头部插入一个新的节点，并且返回指向这个新加入的节点的一个引用（这个节点指向了链表的剩余部分）。所有其他现场仍然保留了这个链表之前的第一个节点，对于这些线程来说链表仍然是为改变的。它们无法看到新加入的元素。</p>
<p>这种可持久化的列表采用链表来实现。不幸的是链表在现代硬件上表现的不太好。链表中得每个元素都是一个独立的对象，这些对象可以遍布在整个计算机内存中。现代CPU能够更快的进行顺序访问，所以你可以在现代的硬件上用数组实现的列表，以获得更高的性能。数组可以顺序的保存数据。CPU缓存能够一次加载数组的一大块进行缓存，一旦加载完成CPU就可以直接访问缓存中的数据。这对于元素散落在RAM中的链表来说，不太可能做得到。</p>
<h3>无状态的工作者</h3>
<p>共享状态能够被系统中得其他线程修改。所以工作者在每次需要的时候必须重读状态，以确保每次都能访问到最新的副本，不管共享状态是保存在内存中的还是在外部数据库中。工作者无法在内部保存这个状态（但是每次需要的时候可以重读）称为无状态的。</p>
<p>每次都重读需要的数据，将会导致速度变慢，特别是状态保存在外部数据库中的时候。</p>
<h3>任务顺序是不确定的</h3>
<p>并行工作者模式的另一个缺点是，作业执行顺序是不确定的。无法保证哪个作业最先或者最后被执行。作业A可能在作业B之前就被分配工作者了，但是作业B反而有可能在作业A之前执行。</p>
<p>并行工作者模式的这种非确定性的特性，使得很难在任何特定的时间点推断系统的状态。这也使得它也更难（如果不是不可能的话）保证一个作业在其他作业之前被执行。</p>
<h1>流水线模式</h1>
<p>第二种并发模型我们称之为流水线并发模型。我之所以选用这个名字，只是为了配合“并行工作者”的隐喻。其他开发者可能会根据平台或社区选择其他称呼（比如说反应器系统，或事件驱动系统）。下图表示一个流水线并发模型：<br />
<img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-3.png" alt="流水线并发模型" /></p>
<p>类似于工厂中生产线上的工人们那样组织工作者。每个工作者只负责作业中的部分工作。当完成了自己的这部分工作时工作者会将作业转发给下一个工作者。每个工作者在自己的线程中运行，并且不会和其他工作者共享状态。有时也被成为<em>无共享</em>并行模型。</p>
<p>通常使用非阻塞的IO来设计使用流水线并发模型的系统。非阻塞IO意味着，一旦某个工作者开始一个IO操作的时候（比如读取文件或从网络连接中读取数据），这个工作者不会一直等待IO操作的结束。IO操作速度很慢，所以等待IO操作结束很浪费CPU时间。此时CPU可以做一些其他事情。当IO操作完成的时候，IO操作的结果（比如读出的数据或者数据写完的状态）被传递给下一个工作者。</p>
<p>有了非阻塞IO，就可以使用IO操作确定工作者之间的边界。工作者会尽可能多运行直到遇到并启动一个IO操作。然后交出作业的控制权。当IO操作完成的时候，在流水线上的下一个工作者继续进行操作，直到它也遇到并启动一个IO操作。<br />
<img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-4.png" alt="No-blocking-IO" /></p>
<p>在实际应用中，作业有可能不会沿着单一流水线进行。由于大多数系统可以执行多个作业，作业从一个工作者流向另一个工作者取决于作业需要做的工作。在实际中可能会有多个不同的虚拟流水线同时运行。这是现实当中作业在流水线系统中可能的移动情况：<br />
<img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-5.png" alt="multi-assembly-line" /></p>
<p>作业甚至也有可能被转发到超过一个工作者上并发处理。比如说，作业有可能被同时转发到作业执行器和作业日志器。下图说明了三条流水线是如何通过将作业转发给同一个工作者（中间流水线的最后一个工作者）来完成作业:<br />
<img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-6.png" alt="complex-condition" /></p>
<p>流水线有时候比这个情况更加复杂。</p>
<h3>反应器，事件驱动系统</h3>
<p>采用流水线并发模型的系统有时候也称为反应器系统或事件驱动系统。系统内的工作者对系统内出现的事件做出反应，这些事件也有可能来自于外部世界或者发自其他工作者。事件可以是传入的HTTP请求，也可以是某个文件成功加载到内存中等。在写这篇文章的时候，已经有很多有趣的反应器/事件驱动平台可以使用了，并且不久的将来会有更多。比较流行的似乎是这几个：</p>
<ul>
<li><a title="Vert.x" href="http://tutorials.jenkov.com/vert.x/index.html" target="_blank" rel="noopener">Vert.x</a></li>
<li>AKKa</li>
<li>Node.JS(JavaScript)</li>
</ul>
<p>我个人觉得Vert.x是相当有趣的（特别是对于我这样使用Java/JVM的人来说）</p>
<h3>Actors 和 Channels</h3>
<p>Actors 和 channels 是两种比较类似的流水线（或反应器/事件驱动）模型。</p>
<p>在Actor模型中每个工作者被称为actor。Actor之间可以直接异步地发送和处理消息。Actor可以被用来实现一个或多个像前文描述的那样的作业处理流水线。下图给出了Actor模型：<br />
<img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-7.png" alt="actor-model" /></p>
<p>而在Channel模型中，工作者之间不直接进行通信。相反，它们在不同的通道中发布自己的消息（事件）。其他工作者们可以在这些通道上监听消息，发送者无需知道谁在监听。下图给出了Channel模型：<br />
<img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-8.png" alt="channel-model" /></p>
<p>在写这篇文章的时候，channel模型对于我来说似乎更加灵活。一个工作者无需知道谁在后面的流水线上处理作业。只需知道作业（或消息等）需要转发给哪个通道。通道上的监听者可以随意订阅或者取消订阅，并不会影响向这个通道发送消息的工作者。这使得工作者之间具有松散的耦合。</p>
<h1>流水线模型的优点</h1>
<p>相比并行工作者模型，流水线并发模型具有几个优点，在接下来的章节中我会介绍几个最大的优点。</p>
<h3>无需共享的状态</h3>
<p>工作者之间无需共享状态，意味着实现的时候无需考虑所有因并发访问共享对象而产生的并发性问题。这使得在实现工作者的时候变得非常容易。在实现工作者的时候就好像是单个线程在处理工作-基本上是一个单线程的实现。</p>
<h3>有状态的工作者</h3>
<p>当工作者知道了没有其他线程可以修改它们的数据，工作者可以变成有状态的。对于有状态，我是指，它们可以在内存中保存它们需要操作的数据，只需在最后将更改写回到外部存储系统。因此，有状态的工作者通常比无状态的工作者具有更高的性能。</p>
<h3>较好的硬件整合（Hardware Conformity）</h3>
<p>单线程代码在整合底层硬件的时候往往具有更好的优势。首先，当能确定代码只在单线程模式下执行的时候，通常能够创建更优化的数据结构和算法。</p>
<p>其次，像前文描述的那样，单线程有状态的工作者能够在内存中缓存数据。在内存中缓存数据的同时，也意味着数据很有可能也缓存在执行这个线程的CPU的缓存中。这使得访问缓存的数据变得更快。</p>
<p>我说的硬件整合是指，以某种方式编写的代码，使得能够自然地受益于底层硬件的工作原理。有些开发者称之为<em>mechanical sympathy</em>。我更倾向于硬件整合这个术语，因为计算机只有很少的机械部件，并且能够隐喻“更好的匹配（match better）”，相比“同情（sympathy）”这个词在上下文中的意思，我觉得“conform”这个词表达的非常好。当然了，这里有点吹毛求疵了，用自己喜欢的术语就行。</p>
<h3>合理的作业顺序</h3>
<p>基于流水线并发模型实现的并发系统，在某种程度上是有可能保证作业的顺序的。作业的有序性使得它更容易地推出系统在某个特定时间点的状态。更进一步，你可以将所有到达的作业写入到日志中去。一旦这个系统的某一部分挂掉了，该日志就可以用来重头开始重建系统当时的状态。按照特定的顺序将作业写入日志，并按这个顺序作为有保障的作业顺序。下图展示了一种可能的设计：<br />
<img src="http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-8.png" alt="job-ordering" /></p>
<p>实现一个有保障的作业顺序是不容易的，但往往是可行的。如果可以，它将大大简化一些任务，例如备份、数据恢复、数据复制等，这些都可以通过日志文件来完成。</p>
<h1>流水线模型的缺点</h1>
<p>流水线并发模型最大的缺点是作业的执行往往分布到多个工作者上，并因此分布到项目中的多个类上。这样导致在追踪某个作业到底被什么代码执行时变得困难。</p>
<p>同样，这也加大了代码编写的难度。有时会将工作者的代码写成回调处理的形式。若在代码中嵌入过多的回调处理，往往会出现所谓的回调地狱（callback hell）现象。所谓回调地狱，就是意味着在追踪代码在回调过程中到底做了什么，以及确保每个回调只访问它需要的数据的时候，变得非常困难</p>
<p>使用并行工作者模型可以简化这个问题。你可以打开工作者的代码，从头到尾优美的阅读被执行的代码。当然并行工作者模式的代码也可能同样分布在不同的类中，但往往也能够很容易的从代码中分析执行的顺序。</p>
<h1>函数式并行（Functional Parallelism）</h1>
<p>第三种并发模型是函数式并行模型，这是也最近（2015）讨论的比较多的一种模型。函数式并行的基本思想是采用函数调用实现程序。函数可以看作是”代理人（agents）“或者”actor“，函数之间可以像流水线模型（AKA 反应器或者事件驱动系统）那样互相发送消息。某个函数调用另一个函数，这个过程类似于消息发送。</p>
<p>函数都是通过拷贝来传递参数的，所以除了接收函数外没有实体可以操作数据。这对于避免共享数据的竞态来说是很有必要的。同样也使得函数的执行类似于原子操作。每个函数调用的执行独立于任何其他函数的调用。</p>
<p>一旦每个函数调用都可以独立的执行，它们就可以分散在不同的CPU上执行了。这也就意味着能够在多处理器上并行的执行使用函数式实现的算法。</p>
<p>Java7中的java.util.concurrent包里包含的<a href="http://tutorials.jenkov.com/java-util-concurrent/java-fork-and-join-forkjoinpool.html">ForkAndJoinPool</a>能够帮助我们实现类似于函数式并行的一些东西。而Java8中并行<a href="http://tutorials.jenkov.com/java-collections/streams.html">streams</a>能够用来帮助我们并行的迭代大型集合。记住有些开发者对ForkAndJoinPool进行了批判（你可以在我的ForkAndJoinPool教程里面看到批评的链接）。</p>
<p>函数式并行里面最难的是确定需要并行的那个函数调用。跨CPU协调函数调用需要一定的开销。某个函数完成的工作单元需要达到某个大小以弥补这个开销。如果函数调用作用非常小，将它并行化可能比单线程、单CPU执行还慢。</p>
<p>我个人认为（可能不太正确），你可以使用反应器或者事件驱动模型实现一个算法，像函数式并行那样的方法实现工作的分解。使用事件驱动模型可以更精确的控制如何实现并行化（我的观点）。</p>
<p>此外，将任务拆分给多个CPU时协调造成的开销，仅仅在该任务是程序当前执行的唯一任务时才有意义。但是，如果当前系统正在执行多个其他的任务时（比如web服务器，数据库服务器或者很多其他类似的系统），将单个任务进行并行化是没有意义的。不管怎样计算机中的其他CPU们都在忙于处理其他任务，没有理由用一个慢的、函数式并行的任务去扰乱它们。使用流水线（反应器）并发模型可能会更好一点，因为它开销更小（在单线程模式下顺序执行）同时能更好的与底层硬件整合。</p>
<h1>使用那种并发模型最好？</h1>
<p>所以，用哪种并发模型更好呢?</p>
<p>通常情况下，这个答案取决于你的系统打算做什么。如果你的作业本身就是并行的、独立的并且没有必要共享状态，你可能会使用并行工作者模型去实现你的系统。虽然许多作业都不是自然并行和独立的。对于这种类型的系统，我相信使用流水线并发模型能够更好的发挥它的优势，而且比并行工作者模型更有优势。</p>
<p>你甚至不用亲自编写所有流水线模型的基础结构。像Vert.x这种现代化的平台已经为你实现了很多。我也会去为探索如何设计我的下一个项目，使它运行在像Vert.x这样的优秀平台上。我感觉Java EE已经没有任何优势了。</p>
<div>
<p><strong>原创文章，转载请注明：</strong> 转载自<a href="http://ifeve.com/">并发编程网 – ifeve.com</a><strong>本文链接地址:</strong> <a href="http://ifeve.com/%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%9e%8b/">并发编程模型</a></p>
</div>
</div>
]]></content:encoded>
			<wfw:commentRss>https://huster.top/htmls/557.html/feed</wfw:commentRss>
		<slash:comments>2</slash:comments>
		</item>
	</channel>
</rss>
