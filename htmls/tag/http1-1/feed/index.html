<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>HTTP/1.1 &#8211; 三两带走</title>
	<atom:link href="http://rentb.vicp.net/htmls/tag/http1-1/feed" rel="self" type="application/rss+xml" />
	<link>http://huster.top/</link>
	<description>(任天兵)龙安的博客</description>
	<lastBuildDate>Thu, 17 Oct 2019 08:49:32 +0000</lastBuildDate>
	<language>zh-CN</language>
	<sy:updatePeriod>hourly</sy:updatePeriod>
	<sy:updateFrequency>1</sy:updateFrequency>
	<generator>https://wordpress.org/?v=4.9.10</generator>

<image>
	<url>https://huster.top/wp-content/uploads/2018/09/cropped-fish_112.18181818182px_1208536_easyicon.net_-32x32.png</url>
	<title>HTTP/1.1 &#8211; 三两带走</title>
	<link>http://huster.top/</link>
	<width>32</width>
	<height>32</height>
</image> 
	<item>
		<title>HTTP/1.1阅读之响应</title>
		<link>https://huster.top/htmls/166.html</link>
		<comments>https://huster.top/htmls/166.html#respond</comments>
		<pubDate>Mon, 16 Apr 2012 11:29:34 +0000</pubDate>
		<dc:creator><![CDATA[龙安_任天兵]]></dc:creator>
				<category><![CDATA[HTTP/1.1阅读笔记]]></category>
		<category><![CDATA[学习笔记]]></category>
		<category><![CDATA[HTTP/1.1]]></category>
		<category><![CDATA[互联网]]></category>

		<guid isPermaLink="false">http://www.longant.com/?p=166</guid>
		<description><![CDATA[与上一章对应，一个响应信息的包含部分如下： Response = Status-Line ; Section  &#8230; <a href="https://huster.top/htmls/166.html" class="more-link">继续阅读<span class="screen-reader-text">“HTTP/1.1阅读之响应”</span></a>]]></description>
				<content:encoded><![CDATA[<p>与上一章对应，一个响应信息的包含部分如下：</p>
<pre> Response      =        Status-Line               ; Section 6.1
                       *(( general-header        ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.5" rel="xref">4.5</a>
                        | response-header        ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.2" rel="xref">6.2</a>
                        | entity-header ) CRLF)  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.1" rel="xref">7.1</a>
                       CRLF
                       [ message-body ]          ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.2" rel="xref">7.2</a>
其中比较重要的是Status-line行，他由以下部分组成：</pre>
<pre>Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF</pre>
<p><span id="more-166"></span></p>
<pre>
以请求行不同的是，他把version提到第一个了，接着是Status的Code信息，最后是一个原因解释。Code信息是给程序看得，Reason是给人看的。
状态码一般由一个三位数来决定的，其中，第一位数字决定了错误类型，一共有5种。
1xx表示请求正在进行中
2xx表示请求被接受了
3xx表示请求被重新定向了
4xx表示请求有问题（用户发送的请求有问题）
例如：404表示用户请求了一个不可用的资源
     上一章的405，表示用户请求了一个不被允许的方法，但是501就表示，这个方法，服务器没有被实现，对
5xx就表示服务器端的错误。
具体的如下：</pre>
<pre>      Status-Code    =
            "100"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.1.1" rel="xref">10.1.1</a>: Continue
          | "101"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.1.2" rel="xref">10.1.2</a>: Switching Protocols
          | "200"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.2.1" rel="xref">10.2.1</a>: OK
          | "201"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.2.2" rel="xref">10.2.2</a>: Created
          | "202"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.2.3" rel="xref">10.2.3</a>: Accepted
          | "203"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.2.4" rel="xref">10.2.4</a>: Non-Authoritative Information
          | "204"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.2.5" rel="xref">10.2.5</a>: No Content
          | "205"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.2.6" rel="xref">10.2.6</a>: Reset Content
          | "206"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.2.7" rel="xref">10.2.7</a>: Partial Content
          | "300"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.1" rel="xref">10.3.1</a>: Multiple Choices
          | "301"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.2" rel="xref">10.3.2</a>: Moved Permanently
          | "302"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.3" rel="xref">10.3.3</a>: Found
          | "303"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.4" rel="xref">10.3.4</a>: See Other
          | "304"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.5" rel="xref">10.3.5</a>: Not Modified
          | "305"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.6" rel="xref">10.3.6</a>: Use Proxy
          | "307"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.3.8" rel="xref">10.3.8</a>: Temporary Redirect
          | "400"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.1" rel="xref">10.4.1</a>: Bad Request
          | "401"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.2" rel="xref">10.4.2</a>: Unauthorized
          | "402"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.3" rel="xref">10.4.3</a>: Payment Required
          | "403"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.4" rel="xref">10.4.4</a>: Forbidden
          | "404"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.5" rel="xref">10.4.5</a>: Not Found
          | "405"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.6" rel="xref">10.4.6</a>: Method Not Allowed
          | "406"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.7" rel="xref">10.4.7</a>: Not Acceptable</pre>
<pre>          | "407"  ; Section 10.4.8: Proxy Authentication Required
          | "408"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.9" rel="xref">10.4.9</a>: Request Time-out
          | "409"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.10" rel="xref">10.4.10</a>: Conflict
          | "410"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.11" rel="xref">10.4.11</a>: Gone
          | "411"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.12" rel="xref">10.4.12</a>: Length Required
          | "412"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.13" rel="xref">10.4.13</a>: Precondition Failed
          | "413"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.14" rel="xref">10.4.14</a>: Request Entity Too Large
          | "414"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.15" rel="xref">10.4.15</a>: Request-URI Too Large
          | "415"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.16" rel="xref">10.4.16</a>: Unsupported Media Type
          | "416"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.17" rel="xref">10.4.17</a>: Requested range not satisfiable
          | "417"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.4.18" rel="xref">10.4.18</a>: Expectation Failed
          | "500"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.1" rel="xref">10.5.1</a>: Internal Server Error
          | "501"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.2" rel="xref">10.5.2</a>: Not Implemented
          | "502"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.3" rel="xref">10.5.3</a>: Bad Gateway
          | "503"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.4" rel="xref">10.5.4</a>: Service Unavailable
          | "504"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.5" rel="xref">10.5.5</a>: Gateway Time-out
          | "505"  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10.5.6" rel="xref">10.5.6</a>: HTTP Version not supported
          | extension-code</pre>
<pre>      extension-code = 3DIGIT
      Reason-Phrase  = *&lt;TEXT, excluding CR, LF&gt;
还不够！！ 这些还能够根据需要而被扩展，没准HTTP/1.2又搞出一堆其他的什么出来。然后可是，服务器端并不需要理解所有的Status-Code，尽管，
我们希望如此，如果一个Status-code未被理解，将被解释成x00，例如你来一个532，根本没这玩意儿，将被解释成500.
同样一个响应信息的头域，允许服务器返回附加信息给用户代理，他应该由以下内容组成</pre>
<pre>       response-header = Accept-Ranges           ; Section 14.5
                       | Age                     ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.6" rel="xref">14.6</a>
                       | ETag                    ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.19" rel="xref">14.19</a>
                       | Location                ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.30" rel="xref">14.30</a>
                       | Proxy-Authenticate      ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.33" rel="xref">14.33</a></pre>
<pre>                       | Retry-After             ; Section 14.37
                       | Server                  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.38" rel="xref">14.38</a>
                       | Vary                    ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.44" rel="xref">14.44</a>
                       | WWW-Authenticate        ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.47" rel="xref">14.47</a>
当然，一个未被识别的响应头域，将被看错信息头域。
</pre>
<pre></pre>
]]></content:encoded>
			<wfw:commentRss>https://huster.top/htmls/166.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>HTTP/1.1阅读之请求</title>
		<link>https://huster.top/htmls/163.html</link>
		<comments>https://huster.top/htmls/163.html#respond</comments>
		<pubDate>Mon, 16 Apr 2012 11:13:40 +0000</pubDate>
		<dc:creator><![CDATA[龙安_任天兵]]></dc:creator>
				<category><![CDATA[HTTP/1.1阅读笔记]]></category>
		<category><![CDATA[学习笔记]]></category>
		<category><![CDATA[HTTP/1.1]]></category>

		<guid isPermaLink="false">http://www.longant.com/?p=163</guid>
		<description><![CDATA[5.1 请求消息的构成 在上一章，我们知道一个请求的消息应该由以下几部分组成： Request = Reque &#8230; <a href="https://huster.top/htmls/163.html" class="more-link">继续阅读<span class="screen-reader-text">“HTTP/1.1阅读之请求”</span></a>]]></description>
				<content:encoded><![CDATA[<p>5.1 请求消息的构成</p>
<p>在上一章，我们知道一个请求的消息应该由以下几部分组成：</p>
<pre> Request       = Request-Line              ; Section 5.1
                 *(( general-header        ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.5" rel="xref">4.5</a>
                 | request-header         ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec5.html#sec5.3" rel="xref">5.3</a>
                 | entity-header ) CRLF)  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.1" rel="xref">7.1</a>
                        CRLF
                 [ message-body ]          ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3" rel="xref">4.3</a>
他们是请求头（由请求行、一般头、请求头和信息头）+信息主体构成。我们来看看请求行（Request-Line），他是由下面几部分构成的：
Method sp URI sp HTTP-Version CRLF,我们来像教科书一样，看看各个部分都是干啥的</pre>
<p><span id="more-163"></span></p>
<pre>
5.1.2 方法（Method）
请求的方法一共有以下几种：</pre>
<pre> Method         =     "OPTIONS"                ; Section 9.2
                      | "GET"                    ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.3" rel="xref">9.3</a>
                      | "HEAD"                   ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.4" rel="xref">9.4</a>
                      | "POST"                   ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.5" rel="xref">9.5</a>
                      | "PUT"                    ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.6" rel="xref">9.6</a>
                      | "DELETE"                 ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.7" rel="xref">9.7</a>
                      | "TRACE"                  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.8" rel="xref">9.8</a>
                      | "CONNECT"                ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.9" rel="xref">9.9</a>
                      | extension-method
       extension-method = token
上图的意思是：OPTION是可选的（有那么多种），然后加上Token，我们比较熟悉的是GET、POST、HEAD方法。
源服务器一般将这边能够接受的请求方法写在 Allow header field 这个域中，然后在返回的信息中通知到客户端，因为这些被允许的方法并不是一成不变的。
如果一个方法是在列表，但是又没有允许的情况下，源服务器会返回405错误，如果完全不支持则返回501错误，这以上列表的方法中，GET和HEAD是必须能够支持的。

<a id="sec5.1.2">5.1.2</a> Request-URI</pre>
<pre>Request-URI    = "*" | absoluteURI | abs_path | authority 
统一资源定位符，由以上四种形式构成，他会是他们其中的一种，他是用来定位资源的具体位置的。
其中×定位符，表示这个请求并不定位到具体的资源，他在乎的仅仅是服务器本身，但是必须是方法不应用一个资源时。真心不知道他说的啥意思，平时太少见了。
注意的是，使用代理访问的时候，发给代理的请求必须是absoluteURI这种格式的，代理可以根据需要从cache直接返给用户，或者是将请求发给源服务器。需要
注意的是，代理有可能再发给另外一个代理服务器（不是源服务器），或者直接访问源服务器。为了避免代理间的循环请求。例如，有ABC三个代理，A从B拿数据，B
又从C拿数据，C从A拿数据，这就形成了一个循环（我的理解如此），那么为了避免这个问题，代理必须要能识别出服务器的名字，不管你使用的是别名、数字ip还
是别的啥玩意儿，这样，ABC三个人都互相认识，也就不会出现循环了。一个完整的Reques-line如下：</pre>
<pre> GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.1
所有的HTTP/1.1的服务器，必须能够接受和处理absoluteURI地址</pre>
<pre>authority 这种形式，只能用于CONNECT方法。
对于我们来说，大部分访问是向源服务器或是网管请求的，这时候，Request-URI必须表现成abs_path的形式，而这个时候的网络主机信息就必须以头域里的host轮胎体现了
举例来说，一个访问主机host的请求类似于：</pre>
<pre>  GET /pub/WWW/TheProject.html HTTP/1.1
       Host: www.w3.org
必须注意的是，第一行abs_path是不能缺少的，如果空的时候，应该写成“/”表示网站的根目录
一个透明代理是不应该更改abs_path的，除非是把空的改写成"/"。
如果是以absoluteURI 的形式来进行请求的，那么头域的host信息会被忽略。如果不是这种形式以外的其他形式，应该以头域的host域为准，如果host无效
会返回400错误。（坏请求）
缺少头域的host的http/1.0的请求，可能会使用启发是规则，就是去看，是不是特定的主机。
5.3 请求头域
请求头域能够让客户端添加附件的信息，来告之服务器。其中信息如下：</pre>
<pre>       request-header = Accept                   ; Section 14.1
                      | Accept-Charset           ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.2" rel="xref">14.2</a>
                      | Accept-Encoding          ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.3" rel="xref">14.3</a>
                      | Accept-Language          ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4" rel="xref">14.4</a>
                      | Authorization            ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.8" rel="xref">14.8</a>
                      | Expect                   ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.20" rel="xref">14.20</a>
                      | From                     ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.22" rel="xref">14.22</a>
                      | Host                     ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.23" rel="xref">14.23</a>
                      | If-Match                 ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.24" rel="xref">14.24</a></pre>
<pre>                      | If-Modified-Since        ; Section 14.25
                      | If-None-Match            ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.26" rel="xref">14.26</a>
                      | If-Range                 ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.27" rel="xref">14.27</a>
                      | If-Unmodified-Since      ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.28" rel="xref">14.28</a>
                      | Max-Forwards             ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.31" rel="xref">14.31</a>
                      | Proxy-Authorization      ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.34" rel="xref">14.34</a>
                      | Range                    ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35" rel="xref">14.35</a>
                      | Referer                  ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.36" rel="xref">14.36</a>
                      | TE                       ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.39" rel="xref">14.39</a>
                      | User-Agent               ; Section <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43" rel="xref">14.43</a>

这些个东西，是能够被扩展的。随着HTTP协议版本的增加，可能会增加新的东东，但是如果所有通信方都把他看做请求头域，那么其他不能识别的头域将被当
信息头来处理。</pre>
]]></content:encoded>
			<wfw:commentRss>https://huster.top/htmls/163.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>HTTP/1.1阅读第2～3章</title>
		<link>https://huster.top/htmls/152.html</link>
		<comments>https://huster.top/htmls/152.html#respond</comments>
		<pubDate>Mon, 09 Apr 2012 03:16:57 +0000</pubDate>
		<dc:creator><![CDATA[龙安_任天兵]]></dc:creator>
				<category><![CDATA[HTTP/1.1阅读笔记]]></category>
		<category><![CDATA[HTTP/1.1]]></category>

		<guid isPermaLink="false">http://www.longant.com/?p=152</guid>
		<description><![CDATA[2 符号习惯和一般语法 2.1 扩充的BNF（扩充的 巴科斯-诺尔范式） 本文档规定的所有机制都用两种方法描述 &#8230; <a href="https://huster.top/htmls/152.html" class="more-link">继续阅读<span class="screen-reader-text">“HTTP/1.1阅读第2～3章”</span></a>]]></description>
				<content:encoded><![CDATA[<p>2 符号习惯和一般语法</p>
<p><span id="more-152"></span></p>
<p>2.1 扩充的BNF（扩充的 巴科斯-诺尔范式）<br />
本文档规定的所有机制都用两种方法描述：散文体（prose）和类似于RFC 822 的扩充Backus-Naur Form（BNF）。要理解本规范，使用者需熟悉符号表示法。扩充BNF结构如下：<br />
名字（name）=定义（definition）<br />
名字（name）就是代表规则的名字，规则名里不能包含“&lt;”和“&gt;”，通过等号把规则名和规则定义（definiation）分离开。空格只有在采用延续行缩进来指定跨度多于一行的规则定义的时候才有意义。某些基本规则（basic rules）使用大写字母包含在规则定义里， 如SP，LWS，HT，CRLF，DIGIT，ALPHA，等等。尖括号可以包含在规则定义里，只要它们的存在有利于区分规则名的使用。</p>
<p>“字面文本”（“literal”）<br />
字面文本（literal text）两边用引号。除非声明，字面文本大小写不敏感（译注：如，HEX =&#8221;A&#8221; | &#8220;B&#8221; | &#8220;C&#8221; | &#8220;D&#8221; | &#8220;E&#8221; | &#8220;F&#8221; | &#8220;a&#8221; | &#8220;b&#8221; | &#8220;c&#8221; | &#8220;d&#8221; | &#8220;e&#8221; | &#8220;f&#8221; | DIGIT 里的A，B,C，D等等都是字面文本（literal text））。</p>
<p>规则1 | 规则2</p>
<p>由竖线（“|”）分开的元素是可选的，例如，“yes | no”表示yes或no都是可接受的。</p>
<p>(规则1 规则2)<br />
围在括号里的多个元素视作一个元素。所以，“(elem (foo | bar) elem)”符合的字符串是“elem foo elem”和“elem bar elem”。 实际上是两个元素，但是用一个都足以表达了。</p>
<p>*规则<br />
前面的字符“*”表示重复。完整的形式是“&lt;n&gt;*&lt;m&gt;元素”，表示元素至少出现&lt;n&gt;次，至多出现&lt;m&gt;次。默认值是0和无穷大，所以&#8221;*（元素）&#8221;允许任何数值，包括零；&#8221;1*元素&#8221;至少出现一次；&#8221;1*2element&#8221;允许出现一次或两次。</p>
<p>[规则]<br />
方括号里是任选元素；“[foo bar]”相当于“*1（foo bar）”。选其中一个，且必须选一个。</p>
<p>N 规则<br />
特殊的重复：“&lt;n&gt;（元素）”与“&lt;n&gt;*&lt;n&gt;（元素）”等价；就是说，（元素）正好出现&lt;n&gt;次。这样2DIGIT是一个两位数字，3ALPHA是一个由三个字符组成的字符串。</p>
<p>#规则<br />
类似于“*”，结构“#”是用来定义一系列元素的。完整的形式是&lt;n&gt;#&lt;m&gt;元素，表示至少&lt;n&gt;个<br />
元素，至多&lt;m&gt;个元素，（*表示重复出现多少次）元素之间被一个或多个逗号（“,”）以及可选的线性空白（LWS）隔<br />
开了。这就使得表示列表这样的形式变得非常容易；像(*LWS element *(*LWS &#8220;,&#8221;*LWS element))<br />
就可以表示为1#element无论在哪里使用这个结构，空元素都是允许的，但是不计入元素出现的次数。换句话说 ，“（element ）, , （element） ”是允许的，但是仅仅视为两个元素。因此，在至少需要一个元素的地方，必须存在至少一个非空元素。默认值是0和无穷大，这样，“#element”允许任意零个或多个元素；“1# element”需要至少一个；“1#2element”允许一个或两个元素。</p>
<p>注释（comment）<br />
用分号引导注释。<br />
隐含的*LWS<br />
本规范所描述的语法是基于字（word-based）的。除非特别注明，线性空白（LWS）可以出现在任何两个相邻字之间（标记（token）或引用字符串（quoted-string）），以及相邻字和间隔符之间，但是这并没有改变对一个域的解释。任何两个标记（token）之间必须有至少一个分割符，否则将会被理解为只是一个标记。</p>
<p>2.2基本规则 （basic rule）</p>
<p>下面的规则贯穿于本规范的全文，此规则描述了基本的解析结构。US-ASCII（美国信息交换标准码）编码字符集是由ANSI X3.4-1986[21]定义的。<br />
OCTET（字节） = &lt;任意八比特的数据序列&gt;<br />
CHAR = &lt;任意ASCII字符（ascii码值从 0到127的字节）&gt;<br />
UPALPHA = &lt;任意大写字母&#8221;A&#8221;&#8230;&#8221;Z&#8221;&gt;<br />
LOALPHA = &lt;任意小写字母&#8221;a&#8221;&#8230;&#8221;z&#8221;&gt;<br />
ALPHA = UPALPHA | LOALPHA<br />
DIGIT = &lt;任意数字0，1，&#8230;9&gt;<br />
CTL = &lt;任意控制字符（ascii码值从0 到 31的字节）及删除键DEL（127&gt;<br />
CR = &lt;US-ASCII CR, 回车（13）&gt;<br />
LF = &lt;US-ASCII LF, 换行符（10）&gt;<br />
SP = &lt;US-ASCII SP, 空格（32）&gt;<br />
HT = &lt;US-ASCII HT, 水平制表 （9）&gt;<br />
&lt;&#8220;&gt; = &lt;US-ASCII双引号（34）&gt;</p>
<p>HTTP/1.1 将 CR LF 的序列定义为任何协议元素的行尾标志，但这个规定对实体主体<br />
（endtity-body）除外（要求比较松的应用见附录19.3）。实体主体（entity-body）的行尾标志<br />
是由其相应的媒体类型定义的，如3.7节所述。<br />
CRLF = CR LF</p>
<p>HTTP/1.1 的消息头域值可以折叠成多行，但紧接着的被折叠行由空格（SP）或水平制表（HT）折叠标记开始。所有的线性空白（LWS）包括被折叠行的折叠标记（空格SP或水平制表键HT），具有同SP一样的语义。接收者在解析域值并且将消息转送到下游（downstream）之前可能会将任何线性空白（LWS）替换成单个SP（空格）。<br />
LWS = [CRLF] 1*(SP | HT)</p>
<p>下面的TEXT规则仅仅适用于头域内容和值的描述，不会被消息解释器解析。TEXT里的字可以包含不仅仅是ISO-8859-1[22]里的字符集，也可以包含RFC 2047里规定的字符集。<br />
TEXT = &lt;除CTLs以外的任意OCTET，但包括LWS&gt;<br />
一个CRLF只有作为HTTP消息头域延续的一部分时才在TEXT定义里使用。<br />
十六进制数字字符用在多个协议元素（protocol element）里。<br />
HEX = &#8220;A&#8221; | &#8220;B&#8221; | &#8220;C&#8221; | &#8220;D&#8221; | &#8220;E&#8221; | &#8220;F&#8221;<br />
| &#8220;a&#8221; | &#8220;b&#8221; | &#8220;c&#8221; | &#8220;d&#8221; | &#8220;e&#8221; | &#8220;f&#8221; | DIGIT</p>
<p>许多HTTP/1.1的消息头域值是由LWS或特殊字符分隔的字构成的。这些特殊字符必须先被包<br />
含在引用字符串（quoted string）里之后才能用于参数值（如3.6节定义）里。<br />
token （标记） = 1*&lt;除CTLs与分割符以外的任意CHAR &gt;<br />
separators（分割符） = &#8220;(&#8221; | &#8220;)&#8221; | &#8220;&lt;&#8221; | &#8220;&gt;&#8221; | &#8220;@&#8221;<br />
| &#8220;,&#8221; | &#8220;;&#8221; | &#8220;:&#8221; | &#8220;\&#8221; | &lt;&#8220;&gt;<br />
| &#8220;/&#8221; | &#8220;[&#8221; | &#8220;]&#8221; | &#8220;?&#8221; | &#8220;=&#8221;<br />
| &#8220;{&#8221; | &#8220;}&#8221; | SP | HT<br />
通过用圆括号括起来，注释（comment）可以包含在一些HTTP头域里。注释只能被包含在域<br />
值定义里有“comment”的域里。在其他域里，圆括号被视作域值的一部分。<br />
comment （注释）= &#8220;(&#8221; *(ctext | quoted-pair | comment )” )&#8221;<br />
ctext = &lt;除&#8221;(&#8221; 和 &#8220;)&#8221;以外的任意TEXT &gt;<br />
如果一个TEXT若被包含在双引号里，则当作一个字。<br />
quoted-string = （ &lt;&#8220;&gt; *（qdtext | quoted-pair ） &lt;&#8220;&gt; ）<br />
qdtext = &lt;any TEXT except &lt;&#8220;&gt;&gt;<br />
斜划线（&#8221;\&#8221;）可以被作为单字符的引用机制，但是必须要在quoted-string和comment构造之<br />
内。<br />
quoted-pair = &#8220;\&#8221; CHAR<br />
3 协议参数<br />
3.1 HTTP版本<br />
HTTP使用一个“&lt;major&gt;.&lt;minor&gt;”数字模式来指明协议的版本号。为了进一步的理解HTTP通信，协议的版本号指示了发送端指明消息的格式和能力，而不仅仅是通过双方通信而获得的通信特性。当消息元素的增加不会影响通信行为或扩展了域值时，协议版本是不需要修改的。当协议会因为添加一些特征而做了修改时，&lt;minor&gt;数字就会递增。这些修改不会影响通常的消息解析算法，但它会给消息添加额外的语意（semantic）并且会暗示发送者具有额外的能力。协议的消息格式发生变化时，&lt;major&gt;数字就会增加。HTTP消息的版本在HTTP-Version域被指明，HTTP-Version域在消息的第一行中。</p>
<p>注意major和minor数字必须被看成两个独立整数，每个整数都可以递增，并且可以增大到大于一位数的整数，如HTTP/2.4比HTTP/2.13低，而HTTP/2.4又比HTTP/12.3低。前导0必须被接收者忽略并且不能被发送者发送。</p>
<p>网关或代理服务器版本不能容忍用户端发送过来的高版本的协议的时候，就会触发一个错误。</p>
<p>3.2 通用资源标识符（URI）</p>
<p>URIs有许多名字已为人所知：WWW地址，通用文档标识符，通用资源标识符[3]，以及后来的统一资源定位器（URL）[4]和统一资源名称（URN）[20]。就HTTP而言，通用资源标识符（URI）只是简单的格式化字符串&#8212;通过名称，位置，或其它特征&#8212;识别一个资源。</p>
<p>根据使用的背景，HTTP里的URIs可以表示成绝对（absoulute）形式或相对形式（相对URI基于根URI[11]）。两种形式的区别是根据这样的事实：绝对URI总是以一个模式（scheme）名作为开头，其后是一个冒号。关于URL 更详尽的语法和含义请参看“统一资源标识符<br />
（URI）:一般语法和语义”，RFC 2396 [42]（代替了RFCs 1738 [4]和RFC 1808 [11]）。本规范采用了RFC 2396 里的” URIreference”， &#8220;absoluteURI&#8221; ， &#8220;relativeURI&#8221; ， &#8220;port&#8221; ， &#8220;host&#8221; ， &#8220;abs_path&#8221; ， &#8220;rel_path&#8221;,和&#8221;authority&#8221;的定义格式。</p>
<p>HTTP协议不对URI的长度作事先的限制，服务器必须能够处理任何他们提供资源的URI，并且应该能够处理无限长度的URIs，这种无效长度的URL可能会在客户端以基于GET方式的请求时产生。如果服务器不能处理太长的URI的时候，服务器应该返回414状态码（此状态码代表Request-URI太长）。</p>
<p>在HTTP协议里，http模式（http scheme）被用于定位网络资源（resourse）的位置。本节定义了http URLs这种特定模式（scheme）的语法和语义。<br />
http_URL = &#8220;http:&#8221; &#8220;//&#8221; host [ &#8220;:&#8221; port ] [ abs_path [ &#8220;?&#8221; query ]]<br />
如果端口为空或未给出，就假定为80。它的语义即：已识别的资源存放于正在监听tcp连接的那个端口的服务器上，并且请求资源的的Request-UR为绝对路径（5.1.2节）。无论什么可能的时候，URL 里使用IP 地址都是应该避免的（参看RFC 1900 [24]）。如果绝对地址（abs_path）没有出现在URL 里，那么应该给出&#8221;/&#8221;。如果代理（proxy）收到一个主机（host）名，但是这个主机名不是全称域名（fully quanlified domain name），则代理应该把它的域名加到主机名上。如果代理（proxy）接收了一个全称域名，代理不能改变主机（host）名称。</p>
<p>3.2.3 URI 比较</p>
<p>当比较两个URI是否匹配时，客户应该对整个URI比较时应该区分大小写，并且一个字节一<br />
个字节的比较。 但下面有些特殊情况：<br />
&#8211; 一个为空或未给定的端口等同于URI-refernece（见RFC 2396）里的默认端口;<br />
&#8211; 主机（host）名的比较必须不区分大小写;<br />
&#8211; 模式（scheme）名的比较必须是不区分大小写的;<br />
&#8211; 一个空绝对路径（abs_path）等同于&#8221;/&#8221;。<br />
除了“保留（reserved）”和“不安全（unsafe）”字符集里的字符（参见RFC 2396[42]） ，其它字符和它们的&#8221;%HEXHEX&#8221;编码的效果一样。<br />
例如,以下三个URI是等同的:<br />
http://abc.com:80/~smith/home.html<br />
http://ABC.com/%7Esmith/home.html<br />
http://ABC.com:/%7esmith/home.html<br />
3.3 日期/时间格式（Date/Time Formats）<br />
3.3.1 完整日期 （Full Date）<br />
HTTP应用曾经一直允许三种不同日期/时间格式：<br />
Sun, 06 Nov 1994 08:49:37 GMT ; RFC 822, updated by RFC 1123<br />
Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036<br />
Sun Nov 6 08:49:37 1994 ; ANSI C&#8217;s asctime（） format<br />
第一种格式是作为Internet 标准提出来的，它是一个国定长度的，由RFC 1123 [8]（RFC822[9]的升级版本）定义的一个子集。第二种格式使用比较普遍，但是基于废弃的RFC 850[12]协议，并且没有年份。如果HTTP/1.1客户端和服务器要解析日期，他们必须能接收所有三种格式（为了兼容HTTP/1.0），但是它们只能用RFC 1123 里定义的日期格式来填充头域（header field）的值里用到HTTP-date的地方。<br />
注:日期值的接收者被鼓励能可靠地接收来自于非HTTP应用程序发送的的日期值，例如有时<br />
可以通过代理（proxy）/网关（gateway）向SMTP或NNTP获取或提交消息。<br />
所有的HTTP日期/时间都必须以格林威治时间（GMT）表示。对HTTP而言，GMT完全等同于UTC（世界协调时间）。前两种日期/时间格式里包含“GMT”，它是时区的三个字面的简写，并且当读到一个asctime格式时必须先被假定是GMT时间。HTTP日期（HTTP-date）区分大小写，不能在此语法中除SP之外包含一个多余的LWS。<br />
HTTP-date = rfc1123-date | rfc850-date | asctime-date<br />
rfc1123-date = wkday &#8220;,&#8221; SP date1 SP time SP &#8220;GMT&#8221;<br />
rfc850-date = weekday &#8220;,&#8221; SP date2 SP time SP &#8220;GMT&#8221;<br />
asctime-date = wkday SP date3 SP time SP 4DIGIT<br />
date1 = 2DIGIT SP month SP 4DIGIT<br />
; day month year （e.g., 02 Jun 1982）<br />
date2 = 2DIGIT &#8220;-&#8221; month &#8220;-&#8221; 2DIGIT<br />
; day-month-year （e.g., 02-Jun-82）<br />
date3 = month SP （ 2DIGIT | （ SP 1DIGIT ））<br />
; month day （e.g., Jun 2）<br />
time = 2DIGIT &#8220;:&#8221; 2DIGIT &#8220;:&#8221; 2DIGIT<br />
; 00:00:00 &#8211; 23:59:59<br />
wkday = &#8220;Mon&#8221; | &#8220;Tue&#8221; | &#8220;Wed&#8221;<br />
| &#8220;Thu&#8221; | &#8220;Fri&#8221; | &#8220;Sat&#8221; | &#8220;Sun&#8221;<br />
weekday = &#8220;Monday&#8221; | &#8220;Tuesday&#8221; | &#8220;Wednesday&#8221;month = &#8220;Jan&#8221; | &#8220;Feb&#8221; | &#8220;Mar&#8221; | &#8220;Apr&#8221;<br />
| &#8220;May&#8221; | &#8220;Jun&#8221; | &#8220;Jul&#8221; | &#8220;Aug&#8221;<br />
| &#8220;Sep&#8221; | &#8220;Oct&#8221; | &#8220;Nov&#8221; | &#8220;Dec&#8221;<br />
注意：HTTP对日期/时间格式的要求仅仅应用在协议流的使用。客户和服务器不必把这种格式应用于用户呈现（user presentation），请求记录日志，等等。.</p>
<p>3.3.2 Delta Seconds （秒间隔）<br />
一些HTTP头域（header field）允许时间值以秒为单位，以十进制整数表示，此值代表消息接收后的时间。<br />
delta-seconds = 1*DIGIT</p>
<p>3.4 字符集 （Character Sets）<br />
HTTP使用术语“字符集”的定义，这和MIME中所描述的是一样.<br />
本文档中的术语“字符集”涉及到一种方法，此方法是用单个或多个表将一个字节序列转换成一个字符序列（译注：从这里来看，这应该是一种映射关系，表保存了映射关系）。注意在反方向上无条件的转换是不成立的，因为并不是所有的字符都能在一个给定的字符集里得到，一个字符集里可能提供多个字节序列表征一个特定的字符。这个定义为的是允许不同种类的字符编码从单一简单表映射（如US-ASCII）到复杂表的转换方法，例如利用ISO-2022技术。然而，相关于MIME字符集名字的定义必须要充分指定从字节到字符的映射。特别是利用外部外围信息来精确确定映射是不允许的.<br />
注：这里使用的术语“字符集”一般的被称作一种“字符编码”。不过既然HTTP和MIME在</p>
<p>同一机构注册，术语统一是很重要的。<br />
HTTP字符集的标记（token）是用不区分大小写的。所有的标记由IANA字符集注册机构[19]定<br />
义。<br />
charset = token<br />
尽管HTTP允许用任意标记（token）作为字符集（charset）值，但这个标记已经在IANA字符集注册机构注册过了，那么这个标记必须代表在该注册机构定义的字符集。对那些非IANA定义的字符集，应用程序应该限制使用。<br />
HTTP协议的实现者应该注意IETF字符集的要求[38][41].</p>
<p>3.4.1 丢失字符集（Missing Charset）<br />
一些HTTP/1.0 应用程序当他们解析Content-Type 头时，当发现没有字符集参数（charsetparameter，译注: Content-Type: text/plain; charset=UTF-8，此时charset=UTF-8就是字符集参数）可用时，这意味着接收者必须猜测实体主体（entity body）的字符集到底是什么。如果<br />
发送者希望避免这种情况，他应该在Content-Type头域里包含一个字符集参数，即使字符集是ISO-8859-1的也应该指明，这样就不会让接收者产生混淆。<br />
不幸的是，一些旧的HTTP/1.0客户端不能处理在Content-Type头域里明确指定的字符集参数。HTTP/1.1接收端必须要认真对待发送者提供的字符集；并且当用户代理（user agent，译注：如浏览器）开始呈现一个文档时，虽然用户代理可以猜测文档的字符集，但如果content-type头域里提供了字符集，并且用户代理也支持这种字符集的显示，不管用户代理是否愿意，它必须要利用这种字符集。参见3.7.1节。</p>
<p>3.5 内容编码（Content Codings）<br />
内容编码（content coding）的值表示一种曾经或能被应用于一个实体的编码转换（encodingtransformation）。内容编码主要用于文档的压缩或其它有效的变换，但这种变换必须不能丢失文档的媒体类型的特性，并且不能丢失文档的信息（译注：就像有损压缩和无损压缩，前者不会丢失信息，后者会丢失信息）。实体经常被编码后保存，然后传送出去，并且在接收端被解码。<br />
content-coding = token</p>
<p>所有内容编码（content-coding）的值是不区分大小写的。HTTP/1.1在接受译码 （Accept-Encoding，14.3 节）和内容译码（Content-Encoding）（14.11 节）头域里使用内容编码（content-coding）的值。尽管该值描述了内容编码，更重要的是它指出了一种解码机制，利用<br />
这种机制对实体的编码进行解码。网络分配数字权威（ （IANA）充当内容编码的值标记（token）注册机构。最初，注册表里包<br />
含下列标记:<br />
gzip（压缩程序）<br />
一种由文件压缩程序&#8221;gzip&#8221;（GNU zip）产生的编码格式（在RFC 1952中描述）。这种编码格式是一种具有32位CRC的Lempel-Ziv编码（LZ77）。<br />
compress（压缩）<br />
一种由UNIX文件压缩程序&#8221;compress&#8221;产生的编码格式。这种编码格式是一种具有可适应性的Lempel-Ziv-Welch编码（LZW）。对于将来的编码，用程序名识表征编码格式是不可取。在这里用到他们是因为他们在历史的作用，虽然这样做并不好。为了同以前的HTTP 实现相兼容，应用程序应该将&#8221;x-gzip&#8221;和&#8221;xcompress&#8221;分别等同于&#8221;gzip&#8221;和&#8221;compress&#8221;。<br />
deflate（缩小）<br />
deflate编码是由RFC 1950 [31]定义的&#8221;zlib&#8221;编码格式与RFC 1951 [29]里描述的&#8221;deflate&#8221;压缩<br />
机制的组合的产物。<br />
identity（一致性）<br />
Identity是缺省编码；指明这种编码表明不进行任何编码转换。这种内容编码仅被用于接受译码（Accept-Encoding）头域里，但不能被用在内容译码（Content-Encoding）头域里。.<br />
新的内容编码的值标记（token）应该被注册；为了实现客户和服务器间的互操作性，实现新值的内容编码算法规范应该能公开利用并且能独立实现，并且与本节中被定义的内容编码目的</p>
<p>3.6 传输编码 （Transfer Codings）</p>
<p>3.6.1 块传输编码（Chunked Transfer Coding）</p>
<p>块编码（chunked encoding）改变消息主体使消息主体（message body）成块发送。每一个块有它自己的大小（size）指示器，在所有的块之后会紧接着一个可选的包含实体头域的尾部（trailer）。这种编码允许发送端能动态生成内容，并能携带能让接收端判断消息是否接收完整<br />
的有用信息。</p>
<p>3.7 媒体类型（Media Type）</p>
<p>为了提供开放的，可扩展的数据类型和类型协商，HTTP在Content-Type（14.17节）实体头域和Accept请求头域里利用了网络媒体[17]类型。<br />
media-type = type &#8220;/&#8221; subtype *（ &#8220;;&#8221; parameter ）<br />
type = token<br />
subtype = token<br />
参数（parameter）以一种 属性/值（attribute/value）形式（如3.6节定义）跟随 类型/子类型（type/subtype）。<br />
类型（type），子类型（subtype），和参数（parameter）里属性名称是大小写不敏感的。参数值有可能是大小写敏感的，也可能不是，这根据参数里属性名称的语意。线性空白（LWS）不能被用于类型（type）和子类型（subtype）之间，也不能用于参数的属性和值之间。参数的出现或不出现对处理媒体类型（media-type）可能会有帮助，这取决于它在媒体类型注册表里的定义。<br />
注意一些旧的HTTP应用程序不能识别媒体类型的参数（parameter）。当向一个旧HTTP应用程序发送数据时，发送端只有在被type/subtype定义里需要时才使用类型参数（parameter）。</p>
<p>媒体类型（media-type）值需要被注册到网络数字分配权威（IANA[19]）里。媒体类型的注册程序在RFC 1590[17]中大概描述。使用未经注册的媒体类型是不被鼓励的。</p>
<p>3.7.1 规范化和文本缺省 （Canonicalization and Text Defaults）</p>
<p>3.7.2 多部分类型（Multipart type）</p>
<p>3.8 产品标记 （product Tokens）</p>
<p>3.9 质量值（Quality Values）</p>
<p>3.10 语言标签 （Language Tags）</p>
<p>3.11 实体标签 （Entity Tags）</p>
<p>3.12 范围单位（Range Units）</p>
<p>省略的都是比较不常用的一些约定</p>
]]></content:encoded>
			<wfw:commentRss>https://huster.top/htmls/152.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>HTTP/1.1协议阅读-第一章</title>
		<link>https://huster.top/htmls/131.html</link>
		<comments>https://huster.top/htmls/131.html#respond</comments>
		<pubDate>Thu, 05 Apr 2012 16:39:58 +0000</pubDate>
		<dc:creator><![CDATA[龙安_任天兵]]></dc:creator>
				<category><![CDATA[HTTP/1.1阅读笔记]]></category>
		<category><![CDATA[HTTP/1.1]]></category>

		<guid isPermaLink="false">http://www.longant.com/?p=131</guid>
		<description><![CDATA[我将逐渐完成http/1.1协议的阅读，在此期间，为了加深记忆，会写成一个系列的文章，文中所述，以个人理解为主 &#8230; <a href="https://huster.top/htmls/131.html" class="more-link">继续阅读<span class="screen-reader-text">“HTTP/1.1协议阅读-第一章”</span></a>]]></description>
				<content:encoded><![CDATA[<p>我将逐渐完成http/1.1协议的阅读，在此期间，为了加深记忆，会写成一个系列的文章，文中所述，以个人理解为主，以英文为准，尽量靠近原文档，原因是，下载了一个中文版的，读起来发现很别扭，感觉像是从Google翻译，直接翻译过来的，不知所云。</p>
<p>先强制性的翻译几章，熟悉之后，希望能够加快阅读速度，今天先进第一章。</p>
<p><span id="more-131"></span></p>
<p>part of <a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html" rev="Section">Hypertext Transfer Protocol &#8212; HTTP/1.1</a><br />
RFC 2616 Fielding, et al.</p>
<ol>
<li>介绍</li>
</ol>
<p>1.1 文档的目的</p>
<p>HTTP，超文本传输协议，是为分布式的，联合的（合作式的），超媒体信息系统设计的。最开始是在1990年被WWW所用。他最开始是HTTP/0.9，传输的是未经处理的信息。HTTP/1.0将原始数据，改为传输mime格式的数据。这种格式的数据，包含了在请求/响应语法中的原始数据和修改信息。但是1.0的版本，在代理服务器和缓存方面却是一片空白。再加上，为了两个通信的应用程序能够明确各自的能力，自称http/1.0的协议，迫切的需要改进升级</p>
<p>为了更严格的实现其这些特征，这份协议包含了比1.0更严格的需求。</p>
<p>较之于简单的检索，实际应用中，需要更加强大的搜索，端到端的更新以及注释。http/1.1拥有一个能够知名请求目的的头信息。他需要由url，uri个urn指出的请求方法和信息的参考。（好别扭，实际上是说，他需要由URL、URN和URI指明请求的方法、资源等信息）。MIME格式的数据，本身是用于邮件的。HTTP/1.1协议还用于浏览器到代理，或者到各种互联网系统，包含支持SMTP <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec17.html#bib16" rel="bibref">[16]</a>, NNTP <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec17.html#bib13" rel="bibref">[13]</a>, FTP <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec17.html#bib18" rel="bibref">[18]</a>,等</p>
<p>1.2 阅读须知</p>
<p>关键字 &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in RFC 2119 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec17.html#bib34" rel="bibref">[34]</a>.</p>
<p>如果must或者required未被满足，在实现的时候当然是不允许的，就是说，规定了必须的，在实现的时候，就必须满足。满足了必须，没有满足should的叫做有条件服从，而两者都满足的话，叫做无条件服从。</p>
<p>1.3 术语</p>
<p>连接： 两个程序间，一个稳定的环路</p>
<p>消息：在程序间传输的，基本的HTTP单元。</p>
<p>请求：第五章定义的请求信息</p>
<p>响应：第六章定义的响应信息</p>
<p>资源：由URI定义的在3.2章定义的信息</p>
<p>实体：真正传输的信息，包含了头信息和具体的实体信息</p>
<p>陈述：为内容协商准备的包含响应信息的实体（12章）</p>
<p>内容协商：为了达到最适的传输方式的一个机制</p>
<p>变体：资源可能有一种或多种表现形式，每一种表现形式叫做“变种”(??)。</p>
<p>用户代理： 浏览器、爬虫等。</p>
<p>服务器：接受用户请求，做出相应的服务器。</p>
<p>源服务器：存储着资源的服务器。</p>
<p>代理服务器：扮演者服务器和用户代理的角色，接受用户的请求，转发给服务器，再将服务器返回的内容，转发给用户。</p>
<p>网关：为多个服务器服务的一种服务器。与代理服务器不同的是，他穿着源服务器的外衣，欺骗者请求的服务器，让他们无法察觉。</p>
<p>隧道： vpn的意思。</p>
<p>cache：缓存</p>
<p>cacheable：当一个缓存能够存储一个请求的copy的时候，我们就说这个响应是cacheable的。</p>
<p>一手的：直接从源服务器过来的响应就叫一手的，但是又可能是通过了一个或是多个代理的。</p>
<p>明确的终止时间：当源服务器告之不再从缓存返回数据的时刻，就是明确的终止时间。</p>
<p>启发式的终止时间：在明确终止时间不可用时，被缓存安排的一个终止时间</p>
<p>周期：一个周期就是从发出请求到成功接收到请求的一个时间。</p>
<p>新鲜的生命时间：还在终止时间内进行响应的时候，我们说这个服务器还在新鲜的生命时间内。</p>
<p>新鲜的：还没有超过终止时间时候，发出的响应，可以称为是新鲜的。</p>
<p>腐烂的：对比新鲜的，当终止时间已经超过的时候，发出的响应的内容是腐烂的。</p>
<p>语义透明：当它的使用除了提高了性能既没有影响客户机，也没有影响源服务器的时候，我们就说这个高速缓存工作在语义透明的模式。当高速缓存工作在语义透明模式的时候，客户收到的应答和从源服务器收到的应答是相同的。</p>
<p>验证：一种验证机制（例如使用标签实体或是最后修改时间），用来验证缓存是不是真正的是一个实体的拷贝。</p>
<p>上/下游：上下游描述了信息的流动。</p>
<p>向内/向外：向内和向外是描述了信息的请求和应答路径。向内，就是移向源服务器，向外就是移向代理服务器。</p>
<p>HTTP协议是一种请求/应答协议。 与主机建立连接后，客户以请求方法，URI和协议版本的形式向服务器发送请求，继以类MIME信息，其中包括请求修改，客户信息和可能的正文内容。</p>
<p>服务器用包括消息协议版本和成功或错误代码的状态进行应答，继以包括服务器信息，实体维护信息和可能的实体内容的类MIME消息。HTTP和MIME之间的关系如附录19.4节所阐述。</p>
<p>大部分的HTTP通信由用户代理引发，由应用到一些原服务器上资源的请求构成。最简单的情形，可以经用户代理（UA）和原服务器（O）之间的单一连接（v）完成。请求链&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&gt;用户代理(UA)&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-单一连接（v)&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-原服务器（O） &lt;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;应答链</p>
<p>当一个或一个以上的中介在请求/应答链中出现的时候，会出现更复杂的情形。常见的中介形式有三种：代理，网关和隧道。代理是一种转送工具，它接收绝对形式的URI请求，重写全部或部分消息，然后把重新格式化后的请求发送到URI确定的服务器上。网关是一种接收工具，它充当其他服务器的上层，必要时将请求翻译为下层服务器的协议。隧道不改变消息而充当两个连接之间的中继点；它用于通信需要穿过中介（如防火墙），甚至中介不能理解信息内容的时候。<br />
请求链&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8211;&gt;UA&#8212;&#8211;v&#8212;&#8211;A&#8212;&#8211;v&#8212;&#8211;B&#8212;&#8211;v&#8212;&#8211;C&#8212;&#8211;v&#8212;&#8211;O &lt;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;&#8212;-应答链</p>
<p>上图显示了用户代理和原服务器之间的三个中介（A，B和C)。游历整条链的请求或应答消息需通过四个独立的连接。这个特性很重要，因为某些HTTP通信选项只能应用于到最近的非隧道邻居，链的终点的连接，或者沿着链的所有连接。图表尽管是线性的，每部分可能都在忙于多路同时通信。例如，B可以接收来自不同于A的许多客户的请求，并且／或者转送到不同于C的服务器，与此同时，它还在处理A的请求。</p>
<p>任何非隧道的通信成员都可以使用内部的高速缓存来处理请求。高速缓存的作用是如果沿着链的一个成员对请求采用了高速缓冲的应答，请求/应答链就会大大缩短。以下图解作为结果产生的链，假定B拥有来自O（通过C）的一个从前应答的备份，请求尚未被UA或A缓存。<br />
请求链&#8212;&#8212;&#8212;-&gt;UA&#8212;&#8211;v&#8212;&#8212;&#8212;-A&#8212;&#8211;v&#8212;&#8211;B&#8212;&#8211;C&#8212;-O &lt;&#8212;&#8212;&#8212;应答链</p>
<p>并不是所有的应答都能有效地缓存，一些请求可能含有修改量，对缓存动作有特殊的要求。缓存动作和缓存应答的HTTP要求将在第13节定义。</p>
<p>实际上，目前万维网上有多种结构和配置的高速缓存和代理被实验或使用。这些系统包括节省越洋带宽的全国代理层，广播或多点通信缓存接口， 通过CD-ROM分配子缓存数据的机构，等等。HTTP系统应用在宽频带连接的企业局域网中，通过PDAs的低耗无线连接和断续连接的访问。HTTP1.1的目标是支持各种各样的应用配置，引进协议结构满足那些需要较高可靠性，可以排除故障或至少指示故障的网络应用的要求。</p>
<p>HTTP通信在通常发生在TCP/ＩＰ连接上。默认端口是TCP 80,不过其它端口也可以使用。在互联网或其他网络上，这并不妨碍HTTP应用在其他协议的顶端。http仅仅期望可靠的传输；任何提供这种保证的协议都可以使用；协议传输数据单元的HTTP/1.1请求和应答结构的映象已经超出了本说明书的范围。</p>
<p>在http/1.0中，大部分的实现为每个请求/应答交换使用了新连接。而http/1.1中，一个连接可以用于一个或更多请求/应答交换，虽然连接可能会因为各种原因中断（见第8.1节）。</p>
]]></content:encoded>
			<wfw:commentRss>https://huster.top/htmls/131.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
		<item>
		<title>RFC及标准性文档 RFC2616 HTTP/1.1阅读系列 (一)内容协商</title>
		<link>https://huster.top/htmls/93.html</link>
		<comments>https://huster.top/htmls/93.html#respond</comments>
		<pubDate>Thu, 29 Mar 2012 11:17:36 +0000</pubDate>
		<dc:creator><![CDATA[龙安_任天兵]]></dc:creator>
				<category><![CDATA[HTTP/1.1阅读笔记]]></category>
		<category><![CDATA[HTTP/1.1]]></category>
		<category><![CDATA[RFC]]></category>
		<category><![CDATA[RFC2616]]></category>

		<guid isPermaLink="false">http://www.longant.com/?p=93</guid>
		<description><![CDATA[RFC文档，是搞WEB开发必读的文档，是英文版本的，但是后来网上找的中文版的，翻译的不是很好（孙进超译），很拗 &#8230; <a href="https://huster.top/htmls/93.html" class="more-link">继续阅读<span class="screen-reader-text">“RFC及标准性文档 RFC2616 HTTP/1.1阅读系列 (一)内容协商”</span></a>]]></description>
				<content:encoded><![CDATA[<p>RFC文档，是搞WEB开发必读的文档，是英文版本的，但是后来网上找的中文版的，翻译的不是很好（孙进超译），很拗口，完全不知道他在说什么，还是老老实实看英文的吧，以下是阅读笔记，留下来，加深印象，也留个笔记。</p>
<div>12.1 内容协商</p>
<div>     为什么需要内容协商？大部分的HTTP响应消息，包含人类能够理解的信息主体，自然的，他使用本人最习惯的方式组织，但是人各有异，每个人都不一样，那么服务器怎么跟客户端协调最好的显示方式呢？那么就是内容协商了。有两种内容协商：服务器驱动和代理驱动协商（这里的代理只浏览器，而不是代理服务器，后面可能也用客户端来表示。）。这两种协商能够被联合使用，那时候叫透明协商；当缓存使用服务器提供的代理协商为后续的请求提供服务器驱动协商的时候。</div>
<div><span id="more-93"></span></div>
<div>服务器驱动协商的优点是，能够把代理驱动协商无法描述清楚的东西，搞清楚。另外，当他发给客户端一个最好猜测对于用户是适合的时候，能够避免后续请求的回路延迟（原因不明）。为了改善“最好猜测”，客户端应该包含请求头域，Accept，Accept-language，Accept-encoding 等，这些头域能够描述客户端对请求的喜好。既然是猜测，当然对用户的请求和目的不可能理解的那么透彻，另外当可选的方法很多，而请求很少时候，就得不偿失了（据说，也侵犯了用户的隐私，当然在国内，这个不存在），因为选择多，会使服务器的处理算法逻辑很复杂。</div>
<div>接着说说代理协商，协商的过程发生在，第一个原始响应后，用户代理会从一系列可选的表现形式中选择的，而这些表现形式是包含在初始响应的头或实体主体内的，这一过程可以自动也可以手动。一般用于响应包含不常见的协商参数，或者通过检测请求信息，服务器无法确认最佳约定的时候。当然，他也有缺点，那就是，需要再次发送请求来进行协商，而这一过程只有当有cache的时候才会高效。同时，这个规范还无法自动完成协商。当出错的时候会返回406的状态码</div>
<div>透明协商就是结合两者的优点，当一个缓存收到一个服务器的响应的时候，并且这个响应中包含了协商的信息（代理协商），且，缓存能够理解的时候，稍候的后续请求中，会自动带上这些信息执行服务器协商。他的优点就是结合了前两者的优点，能够清除代理协商第二次请求的延迟，因为缓存能自动的猜测出合适的响应并返回给请求端。</div>
</div>
]]></content:encoded>
			<wfw:commentRss>https://huster.top/htmls/93.html/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
		</item>
	</channel>
</rss>
